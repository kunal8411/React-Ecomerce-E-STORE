{"ast":null,"code":"import { Jwt_token } from '../data/config';\nexport const configureFakeBackend = () => {\n  let users = [{\n    email: 'test@gmail.com',\n    password: 'test123'\n  }];\n  let realFetch = window.fetch;\n\n  window.fetch = function (url, opts) {\n    const isLoggedIn = opts.headers['Authorization'] === `Bearer ${Jwt_token}`;\n    return new Promise((resolve, reject) => {\n      // wrap in timeout to simulate server api call\n      setTimeout(() => {\n        // authenticate - public\n        if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n          const params = opts.body;\n          const user = users.find(x => x.email === params.email && x.password === params.password);\n          if (!user) return error('Username or password is incorrect');\n          return ok(Jwt_token);\n        } // get users - secure\n\n\n        if (url.endsWith('/users') && opts.method === 'GET') {\n          if (!isLoggedIn) return unauthorised();\n          return ok(users);\n        } // pass through any requests not handled above\n\n\n        realFetch(url, opts).then(response => resolve(response)); // private helper functions\n\n        function ok(body) {\n          resolve({\n            ok: true,\n            text: () => Promise.resolve(JSON.stringify(body))\n          });\n        }\n\n        function unauthorised() {\n          resolve({\n            status: 401,\n            text: () => Promise.resolve(JSON.stringify({\n              message: 'Unauthorised'\n            }))\n          });\n        }\n\n        function error(message) {\n          resolve({\n            status: 400,\n            text: () => Promise.resolve(JSON.stringify({\n              message\n            }))\n          });\n        }\n      }, 500);\n    });\n  };\n};\nexport function handleResponse(response) {\n  return response.text().then(text => {\n    const data = text && JSON.parse(text);\n\n    if (!response.ok) {\n      if ([401, 403].indexOf(response.status) !== -1) {\n        // auto logout if 401 Unauthorized or 403 Forbidden response returned from api\n        localStorage.removeItem('token');\n        localStorage.removeItem('profileURL');\n      }\n    }\n\n    return data;\n  });\n}\nexport function authHeader() {\n  // return authorization header with jwt token\n  const currentUser = localStorage.getItem('token');\n\n  if (currentUser) {\n    return {\n      Authorization: `Bearer ${currentUser}`\n    };\n  } else {\n    return {};\n  }\n}","map":{"version":3,"sources":["/home/kunal/Kunal/THEMES/theme/src/services/fack.backend.js"],"names":["Jwt_token","configureFakeBackend","users","email","password","realFetch","window","fetch","url","opts","isLoggedIn","headers","Promise","resolve","reject","setTimeout","endsWith","method","params","body","user","find","x","error","ok","unauthorised","then","response","text","JSON","stringify","status","message","handleResponse","data","parse","indexOf","localStorage","removeItem","authHeader","currentUser","getItem","Authorization"],"mappings":"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","sourcesContent":["import {Jwt_token} from '../data/config'\nexport const configureFakeBackend = () => {\n    let users = [{ email: 'test@gmail.com', password: 'test123'}];\n    let realFetch = window.fetch;\n    window.fetch = function (url, opts) {\n        const isLoggedIn = opts.headers['Authorization'] === `Bearer ${Jwt_token}`;\n        return new Promise((resolve, reject) => {\n            // wrap in timeout to simulate server api call\n            setTimeout(() => {\n                // authenticate - public\n                if (url.endsWith('/users/authenticate') && opts.method === 'POST') {\n                    const params = opts.body;\n                    const user = users.find(x => x.email === params.email && x.password === params.password);\n                    if (!user) return error('Username or password is incorrect');\n                    return ok(Jwt_token);\n                }\n\n                // get users - secure\n                if (url.endsWith('/users') && opts.method === 'GET') {\n                    if (!isLoggedIn) return unauthorised();\n                    return ok(users);\n                }\n\n                // pass through any requests not handled above\n                realFetch(url, opts).then(response => resolve(response));\n\n                // private helper functions\n\n                function ok(body) {\n                    resolve({ ok: true, text: () => Promise.resolve(JSON.stringify(body)) })\n                }\n\n                function unauthorised() {\n                    resolve({ status: 401, text: () => Promise.resolve(JSON.stringify({ message: 'Unauthorised' })) })\n                }\n\n                function error(message) {\n                    \n                    resolve({ status: 400, text: () => Promise.resolve(JSON.stringify({ message })) })\n                }\n            }, 500);\n        });\n    }\n}\n\nexport function handleResponse(response) {\n    return response.text().then(text => {\n        const data = text && JSON.parse(text);\n        if (!response.ok) {\n            if ([401, 403].indexOf(response.status) !== -1) {\n                // auto logout if 401 Unauthorized or 403 Forbidden response returned from api\n                localStorage.removeItem('token')\n                localStorage.removeItem('profileURL')\n            }\n        }\n        return data;\n    }); \n}\n\nexport function authHeader() {\n    // return authorization header with jwt token\n    const currentUser = localStorage.getItem('token')\n    if (currentUser) {\n        return { Authorization: `Bearer ${currentUser}` };\n    }else {\n        return {};\n    }\n}"]},"metadata":{},"sourceType":"module"}