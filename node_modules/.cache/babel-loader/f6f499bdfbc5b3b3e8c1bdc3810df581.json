{"ast":null,"code":"ace.define(\"ace/mode/ruby_highlight_rules\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text_highlight_rules\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\n\n  var constantOtherSymbol = exports.constantOtherSymbol = {\n    token: \"constant.other.symbol.ruby\",\n    // symbol\n    regex: \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n  };\n  exports.qString = {\n    token: \"string\",\n    // single line\n    regex: \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n  };\n  exports.qqString = {\n    token: \"string\",\n    // single line\n    regex: '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n  };\n  exports.tString = {\n    token: \"string\",\n    // backtick string\n    regex: \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n  };\n  var constantNumericHex = exports.constantNumericHex = {\n    token: \"constant.numeric\",\n    // hex\n    regex: \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n  };\n  var constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n  };\n  var constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n  };\n  var constantNumericOctal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n  };\n  var constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\",\n    //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n  };\n  var constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\",\n    //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n  };\n  var constantNumericFloat = exports.constantNumericFloat = {\n    token: \"constant.numeric\",\n    // float + complex\n    regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n  };\n  var instanceVariable = exports.instanceVariable = {\n    token: \"variable.instance\",\n    // instance variable\n    regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n  };\n\n  var RubyHighlightRules = function () {\n    var builtinFunctions = \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" + \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" + \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" + \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" + \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" + \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" + \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" + \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" + \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" + \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" + \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" + \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" + \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" + \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" + \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" + \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" + \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" + \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" + \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" + \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" + \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" + \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" + \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" + \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" + \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" + \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" + \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" + \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" + \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" + \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" + \"private_class_method|remove_method|undef_method\";\n    var keywords = \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" + \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" + \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\";\n    var buildinConstants = \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" + \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\";\n    var builtinVariables = \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" + \"$!|root_url|flash|session|cookies|params|request|response|logger|self\";\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n      \"keyword\": keywords,\n      \"constant.language\": buildinConstants,\n      \"variable.language\": builtinVariables,\n      \"support.function\": builtinFunctions,\n      \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n\n    }, \"identifier\");\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n    var closeParen = {\n      \"(\": \")\",\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"<\": \">\",\n      \"^\": \"^\",\n      \"|\": \"|\",\n      \"%\": \"%\"\n    };\n    this.$rules = {\n      \"start\": [{\n        token: \"comment\",\n        regex: \"#.*$\"\n      }, {\n        token: \"comment.multiline\",\n        // multi line comment\n        regex: \"^=begin(?=$|\\\\s.*$)\",\n        next: \"comment\"\n      }, {\n        token: \"string.regexp\",\n        regex: /[/](?=.*\\/)/,\n        next: \"regex\"\n      }, [{\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(\")/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /\"/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        regex: /`/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: escapedChars\n        }, {\n          token: \"paren.start\",\n          regex: /#{/,\n          push: \"start\"\n        }, {\n          token: \"string.end\",\n          regex: /`/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: [\"constant.other.symbol.ruby\", \"string.start\"],\n        regex: /(:)?(')/,\n        push: [{\n          token: \"constant.language.escape\",\n          regex: /\\\\['\\\\]/\n        }, {\n          token: \"string.end\",\n          regex: /'/,\n          next: \"pop\"\n        }, {\n          defaultToken: \"string\"\n        }]\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[qwx]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.start\",\n        //doesn't see any differences between strings and array of strings in highlighting\n        regex: /%[QWX]?([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"qStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[si]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithoutInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        //doesn't see any differences between symbols and array of symbols in highlighting\n        regex: /%[SI]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"sStateWithInterpolation\";\n          return this.token;\n        }\n      }, {\n        token: \"string.regexp\",\n        regex: /%[r]([(\\[<{^|%])/,\n        onMatch: function (val, state, stack) {\n          if (stack.length) stack = [];\n          var paren = val[val.length - 1];\n          stack.unshift(paren, state);\n          this.next = \"rState\";\n          return this.token;\n        }\n      }], {\n        token: \"punctuation\",\n        // namespaces aren't symbols\n        regex: \"::\"\n      }, instanceVariable, {\n        token: \"variable.global\",\n        // global variable\n        regex: \"[$][a-zA-Z_\\\\d]+\"\n      }, {\n        token: \"support.class\",\n        // class name\n        regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n      }, {\n        token: [\"punctuation.operator\", \"support.function\"],\n        regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n      }, {\n        token: [\"punctuation.operator\", \"identifier\"],\n        regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n      }, {\n        token: \"string.character\",\n        regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /\\?(?=.+:)/\n      }, constantNumericRational, constantNumericComplex, constantOtherSymbol, constantNumericHex, constantNumericFloat, constantNumericBinary, constantNumericDecimal, constantNumericOctal, {\n        token: \"constant.language.boolean\",\n        regex: \"(?:true|false)\\\\b\"\n      }, {\n        token: keywordMapper,\n        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n      }, {\n        token: \"punctuation.separator.key-value\",\n        regex: \"=>\"\n      }, {\n        stateName: \"heredoc\",\n        onMatch: function (value, currentState, stack) {\n          var next = value[2] == '-' || value[2] == '~' ? \"indentedHeredoc\" : \"heredoc\";\n          var tokens = value.split(this.splitRegex);\n          stack.push(next, tokens[3]);\n          return [{\n            type: \"constant\",\n            value: tokens[1]\n          }, {\n            type: \"string\",\n            value: tokens[2]\n          }, {\n            type: \"support.class\",\n            value: tokens[3]\n          }, {\n            type: \"string\",\n            value: tokens[4]\n          }];\n        },\n        regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n        rules: {\n          heredoc: [{\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }],\n          indentedHeredoc: [{\n            token: \"string\",\n            regex: \"^ +\"\n          }, {\n            onMatch: function (value, currentState, stack) {\n              if (value === stack[1]) {\n                stack.shift();\n                stack.shift();\n                this.next = stack[0] || \"start\";\n                return \"support.class\";\n              }\n\n              this.next = \"\";\n              return \"string\";\n            },\n            regex: \".*$\",\n            next: \"start\"\n          }]\n        }\n      }, {\n        regex: \"$\",\n        token: \"empty\",\n        next: function (currentState, stack) {\n          if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\") return stack[0];\n          return currentState;\n        }\n      }, {\n        token: \"keyword.operator\",\n        regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n      }, {\n        token: \"paren.lparen\",\n        regex: \"[[({]\"\n      }, {\n        token: \"paren.rparen\",\n        regex: \"[\\\\])}]\",\n        onMatch: function (value, currentState, stack) {\n          this.next = '';\n\n          if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n            stack.shift();\n            this.next = stack.shift();\n          }\n\n          return this.token;\n        }\n      }, {\n        token: \"text\",\n        regex: \"\\\\s+\"\n      }, {\n        token: \"punctuation.operator\",\n        regex: /[?:,;.]/\n      }],\n      \"comment\": [{\n        token: \"comment.multiline\",\n        // closing comment\n        regex: \"^=end(?=$|\\\\s.*$)\",\n        next: \"start\"\n      }, {\n        token: \"comment\",\n        // comment spanning whole line\n        regex: \".+\"\n      }],\n      \"qStateWithInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"qStateWithoutInterpolation\": [{\n        token: \"string.start\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n\n          return \"string\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\['\\\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"string.end\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n\n          this.next = '';\n          return \"string\";\n        }\n      }, {\n        defaultToken: \"string\"\n      }],\n      \"sStateWithoutInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"sStateWithInterpolation\": [{\n        token: \"constant.other.symbol.ruby\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        token: \"constant.language.escape\",\n        regex: escapedChars\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\./\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"constant.other.symbol.ruby\",\n        regex: /[)\\]>}^|%]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n\n          this.next = '';\n          return \"constant.other.symbol.ruby\";\n        }\n      }, {\n        defaultToken: \"constant.other.symbol.ruby\"\n      }],\n      \"rState\": [{\n        token: \"string.regexp\",\n        // excluded nested |^% due to difficulty in realization\n        regex: /[(\\[<{]/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val === stack[0]) {\n            stack.unshift(val, state);\n            return this.token;\n          }\n\n          return \"constant.language.escape\";\n        }\n      }, {\n        token: \"paren.start\",\n        regex: /#{/,\n        push: \"start\"\n      }, {\n        token: \"string.regexp\",\n        regex: /\\//\n      }, {\n        token: \"string.regexp\",\n        regex: /[)\\]>}^|%][imxouesn]*/,\n        onMatch: function (val, state, stack) {\n          if (stack.length && val[0] === closeParen[stack[0]]) {\n            stack.shift();\n            this.next = stack.shift();\n            return this.token;\n          }\n\n          this.next = '';\n          return \"constant.language.escape\";\n        }\n      }, {\n        include: \"regex\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex\": [{\n        // character classes\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\[AGbBzZ]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\\\g<[a-zA-Z0-9]*>/\n      }, {\n        token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n      }, {\n        token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n        regex: /(\\\\p{\\^?)([^/]*)(})/\n      }, {\n        // escapes\n        token: \"regexp.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        // flag\n        token: \"string.regexp\",\n        regex: /[/][imxouesn]*/,\n        next: \"start\"\n      }, {\n        // invalid operators\n        token: \"invalid\",\n        regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n      }, {\n        // operators\n        token: \"constant.language.escape\",\n        regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n      }, {\n        token: \"constant.language.delimiter\",\n        regex: /\\|/\n      }, {\n        token: \"regexp.keyword\",\n        regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n      }, {\n        token: \"constant.language.escape\",\n        regex: /\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        defaultToken: \"string.regexp\"\n      }],\n      \"regex_character_class\": [{\n        token: \"regexp.keyword\",\n        regex: /\\\\[wWdDhHsS]/\n      }, {\n        token: \"regexp.charclass.keyword.operator\",\n        regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: /&?&?\\[\\^?/,\n        push: \"regex_character_class\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"]\",\n        next: \"pop\"\n      }, {\n        token: \"constant.language.escape\",\n        regex: \"-\"\n      }, {\n        defaultToken: \"string.regexp.characterclass\"\n      }]\n    };\n    this.normalizeRules();\n  };\n\n  oop.inherits(RubyHighlightRules, TextHighlightRules);\n  exports.RubyHighlightRules = RubyHighlightRules;\n});\nace.define(\"ace/mode/matching_brace_outdent\", [\"require\", \"exports\", \"module\", \"ace/range\"], function (require, exports, module) {\n  \"use strict\";\n\n  var Range = require(\"../range\").Range;\n\n  var MatchingBraceOutdent = function () {};\n\n  (function () {\n    this.checkOutdent = function (line, input) {\n      if (!/^\\s+$/.test(line)) return false;\n      return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function (doc, row) {\n      var line = doc.getLine(row);\n      var match = line.match(/^(\\s*\\})/);\n      if (!match) return 0;\n      var column = match[1].length;\n      var openBracePos = doc.findMatchingBracket({\n        row: row,\n        column: column\n      });\n      if (!openBracePos || openBracePos.row == row) return 0;\n      var indent = this.$getIndent(doc.getLine(openBracePos.row));\n      doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n\n    this.$getIndent = function (line) {\n      return line.match(/^\\s*/)[0];\n    };\n  }).call(MatchingBraceOutdent.prototype);\n  exports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\nace.define(\"ace/mode/folding/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/folding/fold_mode\", \"ace/range\", \"ace/token_iterator\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../../lib/oop\");\n\n  var BaseFoldMode = require(\"./fold_mode\").FoldMode;\n\n  var Range = require(\"../../range\").Range;\n\n  var TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n  var FoldMode = exports.FoldMode = function () {};\n\n  oop.inherits(FoldMode, BaseFoldMode);\n  (function () {\n    this.indentKeywords = {\n      \"class\": 1,\n      \"def\": 1,\n      \"module\": 1,\n      \"do\": 1,\n      \"unless\": 1,\n      \"if\": 1,\n      \"while\": 1,\n      \"for\": 1,\n      \"until\": 1,\n      \"begin\": 1,\n      \"else\": 0,\n      \"elsif\": 0,\n      \"rescue\": 0,\n      \"ensure\": 0,\n      \"when\": 0,\n      \"end\": -1,\n      \"case\": 1,\n      \"=begin\": 1,\n      \"=end\": -1\n    };\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n      var line = session.getLine(row);\n      var isStart = this.foldingStartMarker.test(line);\n      var isEnd = this.foldingStopMarker.test(line);\n\n      if (isStart && !isEnd) {\n        var match = line.match(this.foldingStartMarker);\n\n        if (match[1]) {\n          if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n            if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n              return;\n            }\n\n            if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n              return;\n            }\n          }\n\n          if (match[1] == \"when\") {\n            if (/\\sthen\\s/.test(line) === true) {\n              return;\n            }\n          }\n\n          if (session.getTokenAt(row, match.index + 2).type === \"keyword\") return \"start\";\n        } else if (match[3]) {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"start\";\n        } else {\n          return \"start\";\n        }\n      }\n\n      if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd) return \"\";\n      var match = line.match(this.foldingStopMarker);\n\n      if (match[3] === \"end\") {\n        if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return \"end\";\n      } else if (match[1]) {\n        if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return \"end\";\n      } else return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n      var line = session.doc.getLine(row);\n      var match = this.foldingStartMarker.exec(line);\n\n      if (match) {\n        if (match[1] || match[3]) return this.rubyBlock(session, row, match.index + 2);\n        return this.openingBracketBlock(session, \"{\", row, match.index);\n      }\n\n      var match = this.foldingStopMarker.exec(line);\n\n      if (match) {\n        if (match[3] === \"end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"keyword\") return this.rubyBlock(session, row, match.index + 1);\n        }\n\n        if (match[1] === \"=end\") {\n          if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\") return this.rubyBlock(session, row, match.index + 1);\n        }\n\n        return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n      }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n      var stream = new TokenIterator(session, row, column);\n      var token = stream.getCurrentToken();\n      if (!token || token.type != \"keyword\" && token.type != \"comment.multiline\") return;\n      var val = token.value;\n      var line = session.getLine(row);\n\n      switch (token.value) {\n        case \"if\":\n        case \"unless\":\n        case \"while\":\n        case \"until\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n\n          if (!checkToken.test(line)) {\n            return;\n          }\n\n          var dir = this.indentKeywords[val];\n          break;\n\n        case \"when\":\n          if (/\\sthen\\s/.test(line)) {\n            return;\n          }\n\n        case \"elsif\":\n        case \"rescue\":\n        case \"ensure\":\n          var dir = 1;\n          break;\n\n        case \"else\":\n          var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n\n          if (!checkToken.test(line)) {\n            return;\n          }\n\n          var dir = 1;\n          break;\n\n        default:\n          var dir = this.indentKeywords[val];\n          break;\n      }\n\n      var stack = [val];\n      if (!dir) return;\n      var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n      var startRow = row;\n      var ranges = [];\n      ranges.push(stream.getCurrentTokenRange());\n      stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n\n      if (token.type == \"comment.multiline\") {\n        while (token = stream.step()) {\n          if (token.type !== \"comment.multiline\") continue;\n\n          if (dir == 1) {\n            startColumn = 6;\n\n            if (token.value == \"=end\") {\n              break;\n            }\n          } else {\n            if (token.value == \"=begin\") {\n              break;\n            }\n          }\n        }\n      } else {\n        while (token = stream.step()) {\n          var ignore = false;\n          if (token.type !== \"keyword\") continue;\n          var level = dir * this.indentKeywords[token.value];\n          line = session.getLine(stream.getCurrentTokenRow());\n\n          switch (token.value) {\n            case \"do\":\n              for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                var prevToken = stream.$rowTokens[i];\n\n                if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                  level = 0;\n                  break;\n                }\n              }\n\n              break;\n\n            case \"else\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n\n              if (!checkToken.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n\n              break;\n\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n              var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n\n              if (!checkToken.test(line)) {\n                level = 0;\n                ignore = true;\n              }\n\n              break;\n\n            case \"when\":\n              if (/\\sthen\\s/.test(line) || val == \"case\") {\n                level = 0;\n                ignore = true;\n              }\n\n              break;\n          }\n\n          if (level > 0) {\n            stack.unshift(token.value);\n          } else if (level <= 0 && ignore === false) {\n            stack.shift();\n\n            if (!stack.length) {\n              if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                break;\n              }\n\n              if (token.value == \"do\" && dir == -1 && level != 0) break;\n              if (token.value != \"do\") break;\n            }\n\n            if (level === 0) {\n              stack.unshift(token.value);\n            }\n          }\n        }\n      }\n\n      if (!token) return null;\n\n      if (tokenRange) {\n        ranges.push(stream.getCurrentTokenRange());\n        return ranges;\n      }\n\n      var row = stream.getCurrentTokenRow();\n\n      if (dir === -1) {\n        if (token.type === \"comment.multiline\") {\n          var endColumn = 6;\n        } else {\n          var endColumn = session.getLine(row).length;\n        }\n\n        return new Range(row, endColumn, startRow - 1, startColumn);\n      } else return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n  }).call(FoldMode.prototype);\n});\nace.define(\"ace/mode/ruby\", [\"require\", \"exports\", \"module\", \"ace/lib/oop\", \"ace/mode/text\", \"ace/mode/ruby_highlight_rules\", \"ace/mode/matching_brace_outdent\", \"ace/range\", \"ace/mode/behaviour/cstyle\", \"ace/mode/folding/ruby\"], function (require, exports, module) {\n  \"use strict\";\n\n  var oop = require(\"../lib/oop\");\n\n  var TextMode = require(\"./text\").Mode;\n\n  var RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\n\n  var MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\n\n  var Range = require(\"../range\").Range;\n\n  var CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\n\n  var FoldMode = require(\"./folding/ruby\").FoldMode;\n\n  var Mode = function () {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n  };\n\n  oop.inherits(Mode, TextMode);\n  (function () {\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function (state, line, tab) {\n      var indent = this.$getIndent(line);\n      var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n      var tokens = tokenizedLine.tokens;\n\n      if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n        return indent;\n      }\n\n      if (state == \"start\") {\n        var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n        var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n        var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n        var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n\n        if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n          indent += tab;\n        }\n      }\n\n      return indent;\n    };\n\n    this.checkOutdent = function (state, line, input) {\n      return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function (state, session, row) {\n      var line = session.getLine(row);\n      if (/}/.test(line)) return this.$outdent.autoOutdent(session, row);\n      var indent = this.$getIndent(line);\n      var prevLine = session.getLine(row - 1);\n      var prevIndent = this.$getIndent(prevLine);\n      var tab = session.getTabString();\n\n      if (prevIndent.length <= indent.length) {\n        if (indent.slice(-tab.length) == tab) session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n      }\n    };\n\n    this.getMatching = function (session, row, column) {\n      if (row == undefined) {\n        var pos = session.selection.lead;\n        column = pos.column;\n        row = pos.row;\n      }\n\n      var startToken = session.getTokenAt(row, column);\n      if (startToken && startToken.value in this.indentKeywords) return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n  }).call(Mode.prototype);\n  exports.Mode = Mode;\n});\n\n(function () {\n  ace.require([\"ace/mode/ruby\"], function (m) {\n    if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n      module.exports = m;\n    }\n  });\n})();","map":{"version":3,"sources":["/home/kunal/Kunal/THEMES/theme/node_modules/ace-builds/src-noconflict/mode-ruby.js"],"names":["ace","define","require","exports","module","oop","TextHighlightRules","constantOtherSymbol","token","regex","qString","qqString","tString","constantNumericHex","constantNumericBinary","constantNumericDecimal","constantNumericOctal","constantNumericRational","constantNumericComplex","constantNumericFloat","instanceVariable","RubyHighlightRules","builtinFunctions","keywords","buildinConstants","builtinVariables","keywordMapper","$keywords","createKeywordMapper","escapedChars","closeParen","$rules","next","push","defaultToken","onMatch","val","state","stack","length","paren","unshift","stateName","value","currentState","tokens","split","splitRegex","type","rules","heredoc","shift","indentedHeredoc","include","normalizeRules","inherits","Range","MatchingBraceOutdent","checkOutdent","line","input","test","autoOutdent","doc","row","getLine","match","column","openBracePos","findMatchingBracket","indent","$getIndent","replace","call","prototype","BaseFoldMode","FoldMode","TokenIterator","indentKeywords","foldingStartMarker","foldingStopMarker","getFoldWidget","session","foldStyle","isStart","isEnd","getTokenAt","index","getFoldWidgetRange","exec","rubyBlock","openingBracketBlock","closingBracketBlock","tokenRange","stream","getCurrentToken","checkToken","RegExp","dir","startColumn","startRow","ranges","getCurrentTokenRange","step","stepBackward","stepForward","ignore","level","getCurrentTokenRow","i","$tokenIndex","prevToken","$rowTokens","endColumn","TextMode","Mode","CstyleBehaviour","HighlightRules","$outdent","$behaviour","foldingRules","lineCommentStart","getNextLineIndent","tab","tokenizedLine","getTokenizer","getLineTokens","startingClassOrMethod","startingDoBlock","startingConditional","prevLine","prevIndent","getTabString","slice","remove","getMatching","undefined","pos","selection","lead","startToken","$id","snippetFileId","m"],"mappings":"AAAAA,GAAG,CAACC,MAAJ,CAAW,+BAAX,EAA2C,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,+BAA5C,CAA3C,EAAyH,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAC5J;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,YAAD,CAAjB;;AACA,MAAII,kBAAkB,GAAGJ,OAAO,CAAC,wBAAD,CAAP,CAAkCI,kBAA3D;;AACA,MAAIC,mBAAmB,GAAGJ,OAAO,CAACI,mBAAR,GAA8B;AACpDC,IAAAA,KAAK,EAAG,4BAD4C;AACd;AACtCC,IAAAA,KAAK,EAAG;AAF4C,GAAxD;AAKAN,EAAAA,OAAO,CAACO,OAAR,GAAkB;AACdF,IAAAA,KAAK,EAAG,QADM;AACI;AAClBC,IAAAA,KAAK,EAAG;AAFM,GAAlB;AAKAN,EAAAA,OAAO,CAACQ,QAAR,GAAmB;AACfH,IAAAA,KAAK,EAAG,QADO;AACG;AAClBC,IAAAA,KAAK,EAAG;AAFO,GAAnB;AAKAN,EAAAA,OAAO,CAACS,OAAR,GAAkB;AACdJ,IAAAA,KAAK,EAAG,QADM;AACI;AAClBC,IAAAA,KAAK,EAAG;AAFM,GAAlB;AAKA,MAAII,kBAAkB,GAAGV,OAAO,CAACU,kBAAR,GAA6B;AAClDL,IAAAA,KAAK,EAAG,kBAD0C;AACtB;AAC5BC,IAAAA,KAAK,EAAG;AAF0C,GAAtD;AAKA,MAAIK,qBAAqB,GAAGX,OAAO,CAACW,qBAAR,GAAgC;AACxDN,IAAAA,KAAK,EAAE,kBADiD;AAExDC,IAAAA,KAAK,EAAE;AAFiD,GAA5D;AAKA,MAAIM,sBAAsB,GAAGZ,OAAO,CAACY,sBAAR,GAAiC;AAC1DP,IAAAA,KAAK,EAAE,kBADmD;AAE1DC,IAAAA,KAAK,EAAE;AAFmD,GAA9D;AAKA,MAAIO,oBAAoB,GAAGb,OAAO,CAACY,sBAAR,GAAiC;AACxDP,IAAAA,KAAK,EAAE,kBADiD;AAExDC,IAAAA,KAAK,EAAE;AAFiD,GAA5D;AAKA,MAAIQ,uBAAuB,GAAGd,OAAO,CAACc,uBAAR,GAAkC;AAC5DT,IAAAA,KAAK,EAAE,kBADqD;AACjC;AAC3BC,IAAAA,KAAK,EAAE;AAFqD,GAAhE;AAKA,MAAIS,sBAAsB,GAAGf,OAAO,CAACe,sBAAR,GAAiC;AAC1DV,IAAAA,KAAK,EAAE,kBADmD;AAC/B;AAC3BC,IAAAA,KAAK,EAAE;AAFmD,GAA9D;AAKA,MAAIU,oBAAoB,GAAGhB,OAAO,CAACgB,oBAAR,GAA+B;AACtDX,IAAAA,KAAK,EAAG,kBAD8C;AAC1B;AAC5BC,IAAAA,KAAK,EAAG;AAF8C,GAA1D;AAKA,MAAIW,gBAAgB,GAAGjB,OAAO,CAACiB,gBAAR,GAA2B;AAC9CZ,IAAAA,KAAK,EAAG,mBADsC;AACjB;AAC7BC,IAAAA,KAAK,EAAG;AAFsC,GAAlD;;AAKA,MAAIY,kBAAkB,GAAG,YAAW;AAEhC,QAAIC,gBAAgB,GAChB,kFACA,uFADA,GAEA,yFAFA,GAGA,uFAHA,GAIA,sFAJA,GAKA,iFALA,GAMA,kGANA,GAOA,mFAPA,GAQA,mGARA,GASA,4EATA,GAUA,qGAVA,GAWA,8EAXA,GAYA,4EAZA,GAaA,mGAbA,GAcA,oFAdA,GAeA,gGAfA,GAgBA,iFAhBA,GAiBA,gGAjBA,GAkBA,mGAlBA,GAmBA,6FAnBA,GAoBA,6EApBA,GAqBA,2EArBA,GAsBA,wFAtBA,GAuBA,0FAvBA,GAwBA,iFAxBA,GAyBA,mFAzBA,GA0BA,kFA1BA,GA2BA,iGA3BA,GA4BA,+DA5BA,GA6BA,8GA7BA,GA8BA,iDA/BJ;AAkCA,QAAIC,QAAQ,GACR,qFACA,sFADA,GAEA,8FAHJ;AAMA,QAAIC,gBAAgB,GAChB,sFACA,iJAFJ;AAKA,QAAIC,gBAAgB,GAChB,+EACA,uEAFJ;AAKA,QAAIC,aAAa,GAAG,KAAKC,SAAL,GAAiB,KAAKC,mBAAL,CAAyB;AAC1D,iBAAWL,QAD+C;AAE1D,2BAAqBC,gBAFqC;AAG1D,2BAAqBC,gBAHqC;AAI1D,0BAAoBH,gBAJsC;AAK1D,4BAAsB,UALoC,CAKzB;;AALyB,KAAzB,EAMlC,YANkC,CAArC;AAQA,QAAIO,YAAY,GAAG,0LAAnB;AAEA,QAAIC,UAAU,GAAG;AACb,WAAK,GADQ;AAEb,WAAK,GAFQ;AAGb,WAAK,GAHQ;AAIb,WAAK,GAJQ;AAKb,WAAK,GALQ;AAMb,WAAK,GANQ;AAOb,WAAK;AAPQ,KAAjB;AAUA,SAAKC,MAAL,GAAc;AACV,eAAS,CACL;AACIvB,QAAAA,KAAK,EAAE,SADX;AAEIC,QAAAA,KAAK,EAAE;AAFX,OADK,EAIF;AACCD,QAAAA,KAAK,EAAE,mBADR;AAC6B;AAC5BC,QAAAA,KAAK,EAAE,qBAFR;AAGCuB,QAAAA,IAAI,EAAE;AAHP,OAJE,EAQF;AACCxB,QAAAA,KAAK,EAAE,eADR;AAECC,QAAAA,KAAK,EAAE,aAFR;AAGCuB,QAAAA,IAAI,EAAE;AAHP,OARE,EAcL,CAAC;AACGxB,QAAAA,KAAK,EAAE,CAAC,4BAAD,EAA+B,cAA/B,CADV;AAEGC,QAAAA,KAAK,EAAE,SAFV;AAGGwB,QAAAA,IAAI,EAAE,CAAC;AACHzB,UAAAA,KAAK,EAAE,0BADJ;AAEHC,UAAAA,KAAK,EAAEoB;AAFJ,SAAD,EAGH;AACCrB,UAAAA,KAAK,EAAE,aADR;AAECC,UAAAA,KAAK,EAAE,IAFR;AAGCwB,UAAAA,IAAI,EAAE;AAHP,SAHG,EAOH;AACCzB,UAAAA,KAAK,EAAE,YADR;AAECC,UAAAA,KAAK,EAAE,GAFR;AAGCuB,UAAAA,IAAI,EAAE;AAHP,SAPG,EAWH;AACCE,UAAAA,YAAY,EAAE;AADf,SAXG;AAHT,OAAD,EAiBG;AACC1B,QAAAA,KAAK,EAAE,cADR;AAECC,QAAAA,KAAK,EAAE,GAFR;AAGCwB,QAAAA,IAAI,EAAE,CAAC;AACHzB,UAAAA,KAAK,EAAE,0BADJ;AAEHC,UAAAA,KAAK,EAAEoB;AAFJ,SAAD,EAGH;AACCrB,UAAAA,KAAK,EAAE,aADR;AAECC,UAAAA,KAAK,EAAE,IAFR;AAGCwB,UAAAA,IAAI,EAAE;AAHP,SAHG,EAOH;AACCzB,UAAAA,KAAK,EAAE,YADR;AAECC,UAAAA,KAAK,EAAE,GAFR;AAGCuB,UAAAA,IAAI,EAAE;AAHP,SAPG,EAWH;AACCE,UAAAA,YAAY,EAAE;AADf,SAXG;AAHP,OAjBH,EAkCG;AACC1B,QAAAA,KAAK,EAAE,CAAC,4BAAD,EAA+B,cAA/B,CADR;AAECC,QAAAA,KAAK,EAAE,SAFR;AAGCwB,QAAAA,IAAI,EAAE,CAAC;AACHzB,UAAAA,KAAK,EAAE,0BADJ;AAEHC,UAAAA,KAAK,EAAE;AAFJ,SAAD,EAGH;AACCD,UAAAA,KAAK,EAAE,YADR;AAECC,UAAAA,KAAK,EAAE,GAFR;AAGCuB,UAAAA,IAAI,EAAE;AAHP,SAHG,EAOH;AACCE,UAAAA,YAAY,EAAE;AADf,SAPG;AAHP,OAlCH,EA+CG;AACC1B,QAAAA,KAAK,EAAE,cADR;AACuB;AACtBC,QAAAA,KAAK,EAAE,oBAFR;AAE8B0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC/D,cAAIA,KAAK,CAACC,MAAV,EACID,KAAK,GAAG,EAAR;AACJ,cAAIE,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACG,MAAJ,GAAa,CAAd,CAAf;AACAD,UAAAA,KAAK,CAACG,OAAN,CAAcD,KAAd,EAAqBH,KAArB;AACA,eAAKL,IAAL,GAAY,4BAAZ;AACA,iBAAO,KAAKxB,KAAZ;AACH;AATF,OA/CH,EAyDG;AACCA,QAAAA,KAAK,EAAE,cADR;AACwB;AACvBC,QAAAA,KAAK,EAAE,qBAFR;AAE+B0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAChE,cAAIA,KAAK,CAACC,MAAV,EACID,KAAK,GAAG,EAAR;AACJ,cAAIE,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACG,MAAJ,GAAa,CAAd,CAAf;AACAD,UAAAA,KAAK,CAACG,OAAN,CAAcD,KAAd,EAAqBH,KAArB;AACA,eAAKL,IAAL,GAAY,yBAAZ;AACA,iBAAO,KAAKxB,KAAZ;AACH;AATF,OAzDH,EAmEG;AACCA,QAAAA,KAAK,EAAE,4BADR;AACsC;AACrCC,QAAAA,KAAK,EAAE,mBAFR;AAE6B0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC9D,cAAIA,KAAK,CAACC,MAAV,EACID,KAAK,GAAG,EAAR;AACJ,cAAIE,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACG,MAAJ,GAAa,CAAd,CAAf;AACAD,UAAAA,KAAK,CAACG,OAAN,CAAcD,KAAd,EAAqBH,KAArB;AACA,eAAKL,IAAL,GAAY,4BAAZ;AACA,iBAAO,KAAKxB,KAAZ;AACH;AATF,OAnEH,EA6EG;AACCA,QAAAA,KAAK,EAAE,4BADR;AACsC;AACrCC,QAAAA,KAAK,EAAE,mBAFR;AAE6B0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC9D,cAAIA,KAAK,CAACC,MAAV,EACID,KAAK,GAAG,EAAR;AACJ,cAAIE,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACG,MAAJ,GAAa,CAAd,CAAf;AACAD,UAAAA,KAAK,CAACG,OAAN,CAAcD,KAAd,EAAqBH,KAArB;AACA,eAAKL,IAAL,GAAY,yBAAZ;AACA,iBAAO,KAAKxB,KAAZ;AACH;AATF,OA7EH,EAuFG;AACCA,QAAAA,KAAK,EAAE,eADR;AAECC,QAAAA,KAAK,EAAE,kBAFR;AAE4B0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAC7D,cAAIA,KAAK,CAACC,MAAV,EACID,KAAK,GAAG,EAAR;AACJ,cAAIE,KAAK,GAAGJ,GAAG,CAACA,GAAG,CAACG,MAAJ,GAAa,CAAd,CAAf;AACAD,UAAAA,KAAK,CAACG,OAAN,CAAcD,KAAd,EAAqBH,KAArB;AACA,eAAKL,IAAL,GAAY,QAAZ;AACA,iBAAO,KAAKxB,KAAZ;AACH;AATF,OAvFH,CAdK,EAiHL;AACIA,QAAAA,KAAK,EAAE,aADX;AAC0B;AACtBC,QAAAA,KAAK,EAAE;AAFX,OAjHK,EAqHLW,gBArHK,EAsHL;AACIZ,QAAAA,KAAK,EAAE,iBADX;AAC8B;AAC1BC,QAAAA,KAAK,EAAE;AAFX,OAtHK,EAyHF;AACCD,QAAAA,KAAK,EAAE,eADR;AACyB;AACxBC,QAAAA,KAAK,EAAE;AAFR,OAzHE,EA4HF;AACCD,QAAAA,KAAK,EAAE,CAAC,sBAAD,EAAyB,kBAAzB,CADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OA5HE,EA+HF;AACCD,QAAAA,KAAK,EAAE,CAAC,sBAAD,EAAyB,YAAzB,CADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OA/HE,EAkIF;AACCD,QAAAA,KAAK,EAAE,kBADR;AAECC,QAAAA,KAAK,EAAE,cAAcoB,YAAd,GAA6B;AAFrC,OAlIE,EAqIF;AACCrB,QAAAA,KAAK,EAAE,sBADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OArIE,EA0ILQ,uBA1IK,EA2ILC,sBA3IK,EA4ILX,mBA5IK,EA6ILM,kBA7IK,EA8ILM,oBA9IK,EA+ILL,qBA/IK,EAgJLC,sBAhJK,EAiJLC,oBAjJK,EAkJL;AACIR,QAAAA,KAAK,EAAE,2BADX;AAEIC,QAAAA,KAAK,EAAE;AAFX,OAlJK,EAqJF;AACCD,QAAAA,KAAK,EAAEkB,aADR;AAECjB,QAAAA,KAAK,EAAE;AAFR,OArJE,EAwJF;AACCD,QAAAA,KAAK,EAAE,iCADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAxJE,EA2JF;AACCiC,QAAAA,SAAS,EAAE,SADZ;AAECP,QAAAA,OAAO,EAAE,UAAUQ,KAAV,EAAiBC,YAAjB,EAA+BN,KAA/B,EAAsC;AAC3C,cAAIN,IAAI,GAAIW,KAAK,CAAC,CAAD,CAAL,IAAY,GAAZ,IAAmBA,KAAK,CAAC,CAAD,CAAL,IAAY,GAAhC,GAAuC,iBAAvC,GAA2D,SAAtE;AACA,cAAIE,MAAM,GAAGF,KAAK,CAACG,KAAN,CAAY,KAAKC,UAAjB,CAAb;AACAT,UAAAA,KAAK,CAACL,IAAN,CAAWD,IAAX,EAAiBa,MAAM,CAAC,CAAD,CAAvB;AACA,iBAAO,CACH;AAACG,YAAAA,IAAI,EAAE,UAAP;AAAmBL,YAAAA,KAAK,EAAEE,MAAM,CAAC,CAAD;AAAhC,WADG,EAEH;AAACG,YAAAA,IAAI,EAAE,QAAP;AAAiBL,YAAAA,KAAK,EAAEE,MAAM,CAAC,CAAD;AAA9B,WAFG,EAGH;AAACG,YAAAA,IAAI,EAAE,eAAP;AAAwBL,YAAAA,KAAK,EAAEE,MAAM,CAAC,CAAD;AAArC,WAHG,EAIH;AAACG,YAAAA,IAAI,EAAE,QAAP;AAAiBL,YAAAA,KAAK,EAAEE,MAAM,CAAC,CAAD;AAA9B,WAJG,CAAP;AAMH,SAZF;AAaCpC,QAAAA,KAAK,EAAE,qCAbR;AAcCwC,QAAAA,KAAK,EAAE;AACHC,UAAAA,OAAO,EAAE,CAAC;AACNf,YAAAA,OAAO,EAAE,UAASQ,KAAT,EAAgBC,YAAhB,EAA8BN,KAA9B,EAAqC;AAC1C,kBAAIK,KAAK,KAAKL,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACpBA,gBAAAA,KAAK,CAACa,KAAN;AACAb,gBAAAA,KAAK,CAACa,KAAN;AACA,qBAAKnB,IAAL,GAAYM,KAAK,CAAC,CAAD,CAAL,IAAY,OAAxB;AACA,uBAAO,eAAP;AACH;;AACD,mBAAKN,IAAL,GAAY,EAAZ;AACA,qBAAO,QAAP;AACH,aAVK;AAWNvB,YAAAA,KAAK,EAAE,KAXD;AAYNuB,YAAAA,IAAI,EAAE;AAZA,WAAD,CADN;AAeHoB,UAAAA,eAAe,EAAE,CAAC;AACd5C,YAAAA,KAAK,EAAE,QADO;AAEdC,YAAAA,KAAK,EAAE;AAFO,WAAD,EAGd;AACC0B,YAAAA,OAAO,EAAE,UAASQ,KAAT,EAAgBC,YAAhB,EAA8BN,KAA9B,EAAqC;AAC1C,kBAAIK,KAAK,KAAKL,KAAK,CAAC,CAAD,CAAnB,EAAwB;AACpBA,gBAAAA,KAAK,CAACa,KAAN;AACAb,gBAAAA,KAAK,CAACa,KAAN;AACA,qBAAKnB,IAAL,GAAYM,KAAK,CAAC,CAAD,CAAL,IAAY,OAAxB;AACA,uBAAO,eAAP;AACH;;AACD,mBAAKN,IAAL,GAAY,EAAZ;AACA,qBAAO,QAAP;AACH,aAVF;AAWCvB,YAAAA,KAAK,EAAE,KAXR;AAYCuB,YAAAA,IAAI,EAAE;AAZP,WAHc;AAfd;AAdR,OA3JE,EA0MF;AACCvB,QAAAA,KAAK,EAAE,GADR;AAECD,QAAAA,KAAK,EAAE,OAFR;AAGCwB,QAAAA,IAAI,EAAE,UAASY,YAAT,EAAuBN,KAAvB,EAA8B;AAChC,cAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,SAAb,IAA0BA,KAAK,CAAC,CAAD,CAAL,KAAa,iBAA3C,EACI,OAAOA,KAAK,CAAC,CAAD,CAAZ;AACJ,iBAAOM,YAAP;AACH;AAPF,OA1ME,EAkND;AACApC,QAAAA,KAAK,EAAE,kBADP;AAEAC,QAAAA,KAAK,EAAE;AAFP,OAlNC,EAqNF;AACCD,QAAAA,KAAK,EAAE,cADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OArNE,EAwNF;AACCD,QAAAA,KAAK,EAAE,cADR;AAECC,QAAAA,KAAK,EAAE,SAFR;AAGC0B,QAAAA,OAAO,EAAE,UAASQ,KAAT,EAAgBC,YAAhB,EAA8BN,KAA9B,EAAqC;AAC1C,eAAKN,IAAL,GAAY,EAAZ;;AACA,cAAIW,KAAK,IAAI,GAAT,IAAgBL,KAAK,CAACC,MAAN,GAAe,CAA/B,IAAoCD,KAAK,CAAC,CAAD,CAAL,IAAY,OAApD,EAA6D;AACzDA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACH;;AACD,iBAAO,KAAK3C,KAAZ;AACH;AAVF,OAxNE,EAmOF;AACCA,QAAAA,KAAK,EAAE,MADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAnOE,EAsOF;AACCD,QAAAA,KAAK,EAAE,sBADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAtOE,CADC;AA4OV,iBAAW,CACP;AACID,QAAAA,KAAK,EAAE,mBADX;AACgC;AAC5BC,QAAAA,KAAK,EAAE,mBAFX;AAGIuB,QAAAA,IAAI,EAAE;AAHV,OADO,EAKJ;AACCxB,QAAAA,KAAK,EAAE,SADR;AACmB;AAClBC,QAAAA,KAAK,EAAE;AAFR,OALI,CA5OD;AAsPV,iCAA2B,CAAC;AACxBD,QAAAA,KAAK,EAAE,cADiB;AACF;AACtBC,QAAAA,KAAK,EAAE,SAFiB;AAEN0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACpD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKE,KAAK,CAAC,CAAD,CAAjC,EAAsC;AAClCA,YAAAA,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmBC,KAAnB;AACA,mBAAO,KAAK7B,KAAZ;AACH;;AACD,iBAAO,QAAP;AACH;AARuB,OAAD,EASxB;AACCA,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAEoB;AAFR,OATwB,EAYxB;AACCrB,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAZwB,EAexB;AACCD,QAAAA,KAAK,EAAE,aADR;AAECC,QAAAA,KAAK,EAAE,IAFR;AAGCwB,QAAAA,IAAI,EAAE;AAHP,OAfwB,EAmBxB;AACCzB,QAAAA,KAAK,EAAE,YADR;AAECC,QAAAA,KAAK,EAAE,YAFR;AAEsB0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACvD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKN,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAN,CAAtC,EAAkD;AAC9CA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACA,mBAAO,KAAK3C,KAAZ;AACH;;AACD,eAAKwB,IAAL,GAAY,EAAZ;AACA,iBAAO,QAAP;AACH;AAVF,OAnBwB,EA8BxB;AACCE,QAAAA,YAAY,EAAE;AADf,OA9BwB,CAtPjB;AAuRV,oCAA8B,CAAC;AAC3B1B,QAAAA,KAAK,EAAE,cADoB;AACL;AACtBC,QAAAA,KAAK,EAAE,SAFoB;AAET0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACpD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKE,KAAK,CAAC,CAAD,CAAjC,EAAsC;AAClCA,YAAAA,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmBC,KAAnB;AACA,mBAAO,KAAK7B,KAAZ;AACH;;AACD,iBAAO,QAAP;AACH;AAR0B,OAAD,EAS3B;AACCA,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAT2B,EAY3B;AACCD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAZ2B,EAe3B;AACCD,QAAAA,KAAK,EAAE,YADR;AAECC,QAAAA,KAAK,EAAE,YAFR;AAEsB0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACvD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKN,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAN,CAAtC,EAAkD;AAC9CA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACA,mBAAO,KAAK3C,KAAZ;AACH;;AACD,eAAKwB,IAAL,GAAY,EAAZ;AACA,iBAAO,QAAP;AACH;AAVF,OAf2B,EA0B3B;AACCE,QAAAA,YAAY,EAAE;AADf,OA1B2B,CAvRpB;AAoTV,oCAA8B,CAAC;AAC3B1B,QAAAA,KAAK,EAAE,4BADoB;AACS;AACpCC,QAAAA,KAAK,EAAE,SAFoB;AAET0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACpD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKE,KAAK,CAAC,CAAD,CAAjC,EAAsC;AAClCA,YAAAA,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmBC,KAAnB;AACA,mBAAO,KAAK7B,KAAZ;AACH;;AACD,iBAAO,4BAAP;AACH;AAR0B,OAAD,EAS3B;AACCA,QAAAA,KAAK,EAAE,4BADR;AAECC,QAAAA,KAAK,EAAE,YAFR;AAEsB0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACvD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKN,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAN,CAAtC,EAAkD;AAC9CA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACA,mBAAO,KAAK3C,KAAZ;AACH;;AACD,eAAKwB,IAAL,GAAY,EAAZ;AACA,iBAAO,4BAAP;AACH;AAVF,OAT2B,EAoB3B;AACCE,QAAAA,YAAY,EAAE;AADf,OApB2B,CApTpB;AA2UV,iCAA2B,CAAC;AACxB1B,QAAAA,KAAK,EAAE,4BADiB;AACY;AACpCC,QAAAA,KAAK,EAAE,SAFiB;AAEN0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACpD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKE,KAAK,CAAC,CAAD,CAAjC,EAAsC;AAClCA,YAAAA,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmBC,KAAnB;AACA,mBAAO,KAAK7B,KAAZ;AACH;;AACD,iBAAO,4BAAP;AACH;AARuB,OAAD,EASxB;AACCA,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAEoB;AAFR,OATwB,EAYxB;AACCrB,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAZwB,EAexB;AACCD,QAAAA,KAAK,EAAE,aADR;AAECC,QAAAA,KAAK,EAAE,IAFR;AAGCwB,QAAAA,IAAI,EAAE;AAHP,OAfwB,EAmBxB;AACCzB,QAAAA,KAAK,EAAE,4BADR;AAECC,QAAAA,KAAK,EAAE,YAFR;AAEsB0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACvD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKN,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAN,CAAtC,EAAkD;AAC9CA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACA,mBAAO,KAAK3C,KAAZ;AACH;;AACD,eAAKwB,IAAL,GAAY,EAAZ;AACA,iBAAO,4BAAP;AACH;AAVF,OAnBwB,EA8BxB;AACCE,QAAAA,YAAY,EAAE;AADf,OA9BwB,CA3UjB;AA4WV,gBAAU,CAAC;AACP1B,QAAAA,KAAK,EAAE,eADA;AACgB;AACvBC,QAAAA,KAAK,EAAE,SAFA;AAEW0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AACpD,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,KAAKE,KAAK,CAAC,CAAD,CAAjC,EAAsC;AAClCA,YAAAA,KAAK,CAACG,OAAN,CAAcL,GAAd,EAAmBC,KAAnB;AACA,mBAAO,KAAK7B,KAAZ;AACH;;AACD,iBAAO,0BAAP;AACH;AARM,OAAD,EASP;AACCA,QAAAA,KAAK,EAAE,aADR;AAECC,QAAAA,KAAK,EAAE,IAFR;AAGCwB,QAAAA,IAAI,EAAE;AAHP,OATO,EAaP;AACCzB,QAAAA,KAAK,EAAE,eADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAbO,EAgBP;AACCD,QAAAA,KAAK,EAAE,eADR;AAECC,QAAAA,KAAK,EAAE,uBAFR;AAEiC0B,QAAAA,OAAO,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsBC,KAAtB,EAA6B;AAClE,cAAIA,KAAK,CAACC,MAAN,IAAgBH,GAAG,CAAC,CAAD,CAAH,KAAWN,UAAU,CAACQ,KAAK,CAAC,CAAD,CAAN,CAAzC,EAAqD;AACjDA,YAAAA,KAAK,CAACa,KAAN;AACA,iBAAKnB,IAAL,GAAYM,KAAK,CAACa,KAAN,EAAZ;AACA,mBAAO,KAAK3C,KAAZ;AACH;;AACD,eAAKwB,IAAL,GAAY,EAAZ;AACA,iBAAO,0BAAP;AACH;AAVF,OAhBO,EA4BN;AAACqB,QAAAA,OAAO,EAAE;AAAV,OA5BM,EA6BN;AACInB,QAAAA,YAAY,EAAE;AADlB,OA7BM,CA5WA;AA4YV,eAAS,CACL;AAAC;AACG1B,QAAAA,KAAK,EAAE,gBADX;AAEIC,QAAAA,KAAK,EAAE;AAFX,OADK,EAIF;AACCD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAJE,EAOF;AACCD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAPE,EAUF;AACCD,QAAAA,KAAK,EAAE,CAAC,0BAAD,EAA6B,gBAA7B,EAA+C,0BAA/C,CADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAVE,EAaF;AACCD,QAAAA,KAAK,EAAE,CAAC,0BAAD,EAA6B,SAA7B,EAAwC,0BAAxC,CADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAbE,EAgBF;AAAC;AACAD,QAAAA,KAAK,EAAE,yBADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAhBE,EAmBF;AAAC;AACAD,QAAAA,KAAK,EAAE,eADR;AAECC,QAAAA,KAAK,EAAE,gBAFR;AAGCuB,QAAAA,IAAI,EAAE;AAHP,OAnBE,EAuBF;AAAC;AACAxB,QAAAA,KAAK,EAAE,SADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAvBE,EA0BF;AAAC;AACAD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OA1BE,EA6BF;AACCD,QAAAA,KAAK,EAAE,6BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OA7BE,EAgCF;AACCD,QAAAA,KAAK,EAAE,gBADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAhCE,EAmCF;AACCD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE,OAFR;AAGCwB,QAAAA,IAAI,EAAE;AAHP,OAnCE,EAuCF;AACCC,QAAAA,YAAY,EAAE;AADf,OAvCE,CA5YC;AAubV,+BAAyB,CACrB;AACI1B,QAAAA,KAAK,EAAE,gBADX;AAEIC,QAAAA,KAAK,EAAE;AAFX,OADqB,EAIlB;AACCD,QAAAA,KAAK,EAAE,mCADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAJkB,EAOlB;AACCD,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE,WAFR;AAGCwB,QAAAA,IAAI,EAAE;AAHP,OAPkB,EAWlB;AACCzB,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE,GAFR;AAGCuB,QAAAA,IAAI,EAAE;AAHP,OAXkB,EAelB;AACCxB,QAAAA,KAAK,EAAE,0BADR;AAECC,QAAAA,KAAK,EAAE;AAFR,OAfkB,EAkBlB;AACCyB,QAAAA,YAAY,EAAE;AADf,OAlBkB;AAvbf,KAAd;AA+cA,SAAKoB,cAAL;AACH,GAxhBD;;AA0hBAjD,EAAAA,GAAG,CAACkD,QAAJ,CAAalC,kBAAb,EAAiCf,kBAAjC;AAEAH,EAAAA,OAAO,CAACkB,kBAAR,GAA6BA,kBAA7B;AACC,CA9lBD;AAgmBArB,GAAG,CAACC,MAAJ,CAAW,iCAAX,EAA6C,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,WAA9B,CAA7C,EAAyF,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAC5H;;AAEA,MAAIoD,KAAK,GAAGtD,OAAO,CAAC,UAAD,CAAP,CAAoBsD,KAAhC;;AAEA,MAAIC,oBAAoB,GAAG,YAAW,CAAE,CAAxC;;AAEA,GAAC,YAAW;AAER,SAAKC,YAAL,GAAoB,UAASC,IAAT,EAAeC,KAAf,EAAsB;AACtC,UAAI,CAAE,QAAQC,IAAR,CAAaF,IAAb,CAAN,EACI,OAAO,KAAP;AAEJ,aAAO,SAASE,IAAT,CAAcD,KAAd,CAAP;AACH,KALD;;AAOA,SAAKE,WAAL,GAAmB,UAASC,GAAT,EAAcC,GAAd,EAAmB;AAClC,UAAIL,IAAI,GAAGI,GAAG,CAACE,OAAJ,CAAYD,GAAZ,CAAX;AACA,UAAIE,KAAK,GAAGP,IAAI,CAACO,KAAL,CAAW,UAAX,CAAZ;AAEA,UAAI,CAACA,KAAL,EAAY,OAAO,CAAP;AAEZ,UAAIC,MAAM,GAAGD,KAAK,CAAC,CAAD,CAAL,CAAS3B,MAAtB;AACA,UAAI6B,YAAY,GAAGL,GAAG,CAACM,mBAAJ,CAAwB;AAACL,QAAAA,GAAG,EAAEA,GAAN;AAAWG,QAAAA,MAAM,EAAEA;AAAnB,OAAxB,CAAnB;AAEA,UAAI,CAACC,YAAD,IAAiBA,YAAY,CAACJ,GAAb,IAAoBA,GAAzC,EAA8C,OAAO,CAAP;AAE9C,UAAIM,MAAM,GAAG,KAAKC,UAAL,CAAgBR,GAAG,CAACE,OAAJ,CAAYG,YAAY,CAACJ,GAAzB,CAAhB,CAAb;AACAD,MAAAA,GAAG,CAACS,OAAJ,CAAY,IAAIhB,KAAJ,CAAUQ,GAAV,EAAe,CAAf,EAAkBA,GAAlB,EAAuBG,MAAM,GAAC,CAA9B,CAAZ,EAA8CG,MAA9C;AACH,KAbD;;AAeA,SAAKC,UAAL,GAAkB,UAASZ,IAAT,EAAe;AAC7B,aAAOA,IAAI,CAACO,KAAL,CAAW,MAAX,EAAmB,CAAnB,CAAP;AACH,KAFD;AAIH,GA5BD,EA4BGO,IA5BH,CA4BQhB,oBAAoB,CAACiB,SA5B7B;AA8BAvE,EAAAA,OAAO,CAACsD,oBAAR,GAA+BA,oBAA/B;AACC,CAtCD;AAwCAzD,GAAG,CAACC,MAAJ,CAAW,uBAAX,EAAmC,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,4BAA5C,EAAyE,WAAzE,EAAqF,oBAArF,CAAnC,EAA+I,UAAUC,OAAV,EAAmBC,OAAnB,EAA4BC,MAA5B,EAAoC;AACnL;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,eAAD,CAAjB;;AACA,MAAIyE,YAAY,GAAGzE,OAAO,CAAC,aAAD,CAAP,CAAuB0E,QAA1C;;AACA,MAAIpB,KAAK,GAAGtD,OAAO,CAAC,aAAD,CAAP,CAAuBsD,KAAnC;;AACA,MAAIqB,aAAa,GAAG3E,OAAO,CAAC,sBAAD,CAAP,CAAgC2E,aAApD;;AAGA,MAAID,QAAQ,GAAGzE,OAAO,CAACyE,QAAR,GAAmB,YAAY,CAC7C,CADD;;AAGAvE,EAAAA,GAAG,CAACkD,QAAJ,CAAaqB,QAAb,EAAuBD,YAAvB;AAEA,GAAC,YAAY;AACT,SAAKG,cAAL,GAAsB;AAClB,eAAS,CADS;AAElB,aAAO,CAFW;AAGlB,gBAAU,CAHQ;AAIlB,YAAM,CAJY;AAKlB,gBAAU,CALQ;AAMlB,YAAM,CANY;AAOlB,eAAS,CAPS;AAQlB,aAAO,CARW;AASlB,eAAS,CATS;AAUlB,eAAS,CAVS;AAWlB,cAAQ,CAXU;AAYlB,eAAS,CAZS;AAalB,gBAAU,CAbQ;AAclB,gBAAU,CAdQ;AAelB,cAAQ,CAfU;AAgBlB,aAAO,CAAC,CAhBU;AAiBlB,cAAQ,CAjBU;AAkBlB,gBAAU,CAlBQ;AAmBlB,cAAQ,CAAC;AAnBS,KAAtB;AAsBA,SAAKC,kBAAL,GAA0B,qHAA1B;AACA,SAAKC,iBAAL,GAAyB,qCAAzB;;AAEA,SAAKC,aAAL,GAAqB,UAAUC,OAAV,EAAmBC,SAAnB,EAA8BnB,GAA9B,EAAmC;AACpD,UAAIL,IAAI,GAAGuB,OAAO,CAACjB,OAAR,CAAgBD,GAAhB,CAAX;AACA,UAAIoB,OAAO,GAAG,KAAKL,kBAAL,CAAwBlB,IAAxB,CAA6BF,IAA7B,CAAd;AACA,UAAI0B,KAAK,GAAG,KAAKL,iBAAL,CAAuBnB,IAAvB,CAA4BF,IAA5B,CAAZ;;AAEA,UAAIyB,OAAO,IAAI,CAACC,KAAhB,EAAuB;AACnB,YAAInB,KAAK,GAAGP,IAAI,CAACO,KAAL,CAAW,KAAKa,kBAAhB,CAAZ;;AACA,YAAIb,KAAK,CAAC,CAAD,CAAT,EAAc;AACV,cAAIA,KAAK,CAAC,CAAD,CAAL,IAAY,IAAZ,IAAoBA,KAAK,CAAC,CAAD,CAAL,IAAY,MAAhC,IAA0CA,KAAK,CAAC,CAAD,CAAL,IAAY,OAAtD,IAAiEA,KAAK,CAAC,CAAD,CAAL,IAAY,OAA7E,IAAwFA,KAAK,CAAC,CAAD,CAAL,IAAY,QAAxG,EAAkH;AAC9G,gBAAIA,KAAK,CAAC,CAAD,CAAL,IAAY,MAAZ,IAAsB,eAAeL,IAAf,CAAoBF,IAApB,MAA8B,KAAxD,EAA+D;AAC3D;AACH;;AACD,gBAAI,wCAAwCE,IAAxC,CAA6CF,IAA7C,MAAuD,KAA3D,EAAkE;AAC9D;AACH;AACJ;;AAED,cAAIO,KAAK,CAAC,CAAD,CAAL,IAAY,MAAhB,EAAwB;AACpB,gBAAI,WAAWL,IAAX,CAAgBF,IAAhB,MAA0B,IAA9B,EAAoC;AAChC;AACH;AACJ;;AACD,cAAIuB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,SAAtD,EACI,OAAO,OAAP;AACP,SAjBD,MAiBO,IAAIkB,KAAK,CAAC,CAAD,CAAT,EAAc;AACjB,cAAIgB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,mBAAtD,EACI,OAAO,OAAP;AACP,SAHM,MAGA;AACH,iBAAO,OAAP;AACH;AACJ;;AACD,UAAImC,SAAS,IAAI,cAAb,IAA+B,CAACE,KAAhC,IAAyCD,OAAO,IAAIC,KAAxD,EACI,OAAO,EAAP;AAEJ,UAAInB,KAAK,GAAGP,IAAI,CAACO,KAAL,CAAW,KAAKc,iBAAhB,CAAZ;;AACA,UAAId,KAAK,CAAC,CAAD,CAAL,KAAa,KAAjB,EAAwB;AACpB,YAAIgB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,SAAtD,EACI,OAAO,KAAP;AACP,OAHD,MAGO,IAAIkB,KAAK,CAAC,CAAD,CAAT,EAAc;AACjB,YAAIgB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,mBAAtD,EACI,OAAO,KAAP;AACP,OAHM,MAIH,OAAO,KAAP;AACP,KA3CD;;AA6CA,SAAKwC,kBAAL,GAA0B,UAAUN,OAAV,EAAmBC,SAAnB,EAA8BnB,GAA9B,EAAmC;AACzD,UAAIL,IAAI,GAAGuB,OAAO,CAACnB,GAAR,CAAYE,OAAZ,CAAoBD,GAApB,CAAX;AACA,UAAIE,KAAK,GAAG,KAAKa,kBAAL,CAAwBU,IAAxB,CAA6B9B,IAA7B,CAAZ;;AACA,UAAIO,KAAJ,EAAW;AACP,YAAIA,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAArB,EACI,OAAO,KAAKwB,SAAL,CAAeR,OAAf,EAAwBlB,GAAxB,EAA6BE,KAAK,CAACqB,KAAN,GAAc,CAA3C,CAAP;AAEJ,eAAO,KAAKI,mBAAL,CAAyBT,OAAzB,EAAkC,GAAlC,EAAuClB,GAAvC,EAA4CE,KAAK,CAACqB,KAAlD,CAAP;AACH;;AAED,UAAIrB,KAAK,GAAG,KAAKc,iBAAL,CAAuBS,IAAvB,CAA4B9B,IAA5B,CAAZ;;AACA,UAAIO,KAAJ,EAAW;AACP,YAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,KAAjB,EAAwB;AACpB,cAAIgB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,SAAtD,EACI,OAAO,KAAK0C,SAAL,CAAeR,OAAf,EAAwBlB,GAAxB,EAA6BE,KAAK,CAACqB,KAAN,GAAc,CAA3C,CAAP;AACP;;AAED,YAAIrB,KAAK,CAAC,CAAD,CAAL,KAAa,MAAjB,EAAyB;AACrB,cAAIgB,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBE,KAAK,CAACqB,KAAN,GAAc,CAAtC,EAAyCvC,IAAzC,KAAkD,mBAAtD,EACI,OAAO,KAAK0C,SAAL,CAAeR,OAAf,EAAwBlB,GAAxB,EAA6BE,KAAK,CAACqB,KAAN,GAAc,CAA3C,CAAP;AACP;;AAED,eAAO,KAAKK,mBAAL,CAAyBV,OAAzB,EAAkC,GAAlC,EAAuClB,GAAvC,EAA4CE,KAAK,CAACqB,KAAN,GAAcrB,KAAK,CAAC,CAAD,CAAL,CAAS3B,MAAnE,CAAP;AACH;AACJ,KAxBD;;AA0BA,SAAKmD,SAAL,GAAiB,UAAUR,OAAV,EAAmBlB,GAAnB,EAAwBG,MAAxB,EAAgC0B,UAAhC,EAA4C;AACzD,UAAIC,MAAM,GAAG,IAAIjB,aAAJ,CAAkBK,OAAlB,EAA2BlB,GAA3B,EAAgCG,MAAhC,CAAb;AAEA,UAAI3D,KAAK,GAAGsF,MAAM,CAACC,eAAP,EAAZ;AACA,UAAI,CAACvF,KAAD,IAAWA,KAAK,CAACwC,IAAN,IAAc,SAAd,IAA2BxC,KAAK,CAACwC,IAAN,IAAc,mBAAxD,EACI;AAEJ,UAAIZ,GAAG,GAAG5B,KAAK,CAACmC,KAAhB;AACA,UAAIgB,IAAI,GAAGuB,OAAO,CAACjB,OAAR,CAAgBD,GAAhB,CAAX;;AACA,cAAQxD,KAAK,CAACmC,KAAd;AACI,aAAK,IAAL;AACA,aAAK,QAAL;AACA,aAAK,OAAL;AACA,aAAK,OAAL;AACI,cAAIqD,UAAU,GAAG,IAAIC,MAAJ,CAAW,UAAUzF,KAAK,CAACmC,KAA3B,CAAjB;;AACA,cAAI,CAACqD,UAAU,CAACnC,IAAX,CAAgBF,IAAhB,CAAL,EAA4B;AACxB;AACH;;AACD,cAAIuC,GAAG,GAAG,KAAKpB,cAAL,CAAoB1C,GAApB,CAAV;AACA;;AACJ,aAAK,MAAL;AACI,cAAI,WAAWyB,IAAX,CAAgBF,IAAhB,CAAJ,EAA2B;AACvB;AACH;;AACL,aAAK,OAAL;AACA,aAAK,QAAL;AACA,aAAK,QAAL;AACI,cAAIuC,GAAG,GAAG,CAAV;AACA;;AACJ,aAAK,MAAL;AACI,cAAIF,UAAU,GAAG,IAAIC,MAAJ,CAAW,UAAUzF,KAAK,CAACmC,KAAhB,GAAwB,OAAnC,CAAjB;;AACA,cAAI,CAACqD,UAAU,CAACnC,IAAX,CAAgBF,IAAhB,CAAL,EAA4B;AACxB;AACH;;AACD,cAAIuC,GAAG,GAAG,CAAV;AACA;;AACJ;AACI,cAAIA,GAAG,GAAG,KAAKpB,cAAL,CAAoB1C,GAApB,CAAV;AACA;AA7BR;;AAgCA,UAAIE,KAAK,GAAG,CAACF,GAAD,CAAZ;AACA,UAAI,CAAC8D,GAAL,EACI;AAEJ,UAAIC,WAAW,GAAGD,GAAG,KAAK,CAAC,CAAT,GAAahB,OAAO,CAACjB,OAAR,CAAgBD,GAAG,GAAG,CAAtB,EAAyBzB,MAAtC,GAA+C2C,OAAO,CAACjB,OAAR,CAAgBD,GAAhB,EAAqBzB,MAAtF;AACA,UAAI6D,QAAQ,GAAGpC,GAAf;AACA,UAAIqC,MAAM,GAAG,EAAb;AACAA,MAAAA,MAAM,CAACpE,IAAP,CAAY6D,MAAM,CAACQ,oBAAP,EAAZ;AAEAR,MAAAA,MAAM,CAACS,IAAP,GAAcL,GAAG,KAAK,CAAC,CAAT,GAAaJ,MAAM,CAACU,YAApB,GAAmCV,MAAM,CAACW,WAAxD;;AACA,UAAIjG,KAAK,CAACwC,IAAN,IAAc,mBAAlB,EAAuC;AACnC,eAAOxC,KAAK,GAAGsF,MAAM,CAACS,IAAP,EAAf,EAA8B;AAC1B,cAAI/F,KAAK,CAACwC,IAAN,KAAe,mBAAnB,EACI;;AACJ,cAAIkD,GAAG,IAAI,CAAX,EAAc;AACVC,YAAAA,WAAW,GAAG,CAAd;;AACA,gBAAI3F,KAAK,CAACmC,KAAN,IAAe,MAAnB,EAA2B;AACvB;AACH;AACJ,WALD,MAKO;AACH,gBAAInC,KAAK,CAACmC,KAAN,IAAe,QAAnB,EAA6B;AACzB;AACH;AACJ;AACJ;AACJ,OAfD,MAeO;AACH,eAAOnC,KAAK,GAAGsF,MAAM,CAACS,IAAP,EAAf,EAA8B;AAC1B,cAAIG,MAAM,GAAG,KAAb;AACA,cAAIlG,KAAK,CAACwC,IAAN,KAAe,SAAnB,EACI;AACJ,cAAI2D,KAAK,GAAGT,GAAG,GAAG,KAAKpB,cAAL,CAAoBtE,KAAK,CAACmC,KAA1B,CAAlB;AACAgB,UAAAA,IAAI,GAAGuB,OAAO,CAACjB,OAAR,CAAgB6B,MAAM,CAACc,kBAAP,EAAhB,CAAP;;AACA,kBAAQpG,KAAK,CAACmC,KAAd;AACI,iBAAK,IAAL;AACI,mBAAK,IAAIkE,CAAC,GAAGf,MAAM,CAACgB,WAAP,GAAqB,CAAlC,EAAqCD,CAAC,IAAI,CAA1C,EAA6CA,CAAC,EAA9C,EAAkD;AAC9C,oBAAIE,SAAS,GAAGjB,MAAM,CAACkB,UAAP,CAAkBH,CAAlB,CAAhB;;AACA,oBAAIE,SAAS,KAAKA,SAAS,CAACpE,KAAV,IAAmB,OAAnB,IAA8BoE,SAAS,CAACpE,KAAV,IAAmB,OAAjD,IAA4DoE,SAAS,CAACpE,KAAV,IAAmB,KAApF,CAAb,EAAyG;AACrGgE,kBAAAA,KAAK,GAAG,CAAR;AACA;AACH;AACJ;;AACD;;AACJ,iBAAK,MAAL;AACI,kBAAIX,UAAU,GAAG,IAAIC,MAAJ,CAAW,UAAUzF,KAAK,CAACmC,KAAhB,GAAwB,OAAnC,CAAjB;;AACA,kBAAI,CAACqD,UAAU,CAACnC,IAAX,CAAgBF,IAAhB,CAAD,IAA0BvB,GAAG,IAAI,MAArC,EAA6C;AACzCuE,gBAAAA,KAAK,GAAG,CAAR;AACAD,gBAAAA,MAAM,GAAG,IAAT;AACH;;AACD;;AACJ,iBAAK,IAAL;AACA,iBAAK,QAAL;AACA,iBAAK,OAAL;AACA,iBAAK,OAAL;AACI,kBAAIV,UAAU,GAAG,IAAIC,MAAJ,CAAW,UAAUzF,KAAK,CAACmC,KAA3B,CAAjB;;AACA,kBAAI,CAACqD,UAAU,CAACnC,IAAX,CAAgBF,IAAhB,CAAL,EAA4B;AACxBgD,gBAAAA,KAAK,GAAG,CAAR;AACAD,gBAAAA,MAAM,GAAG,IAAT;AACH;;AACD;;AACJ,iBAAK,MAAL;AACI,kBAAI,WAAW7C,IAAX,CAAgBF,IAAhB,KAAyBvB,GAAG,IAAI,MAApC,EAA4C;AACxCuE,gBAAAA,KAAK,GAAG,CAAR;AACAD,gBAAAA,MAAM,GAAG,IAAT;AACH;;AACD;AAhCR;;AAmCA,cAAIC,KAAK,GAAG,CAAZ,EAAe;AACXrE,YAAAA,KAAK,CAACG,OAAN,CAAcjC,KAAK,CAACmC,KAApB;AACH,WAFD,MAEO,IAAIgE,KAAK,IAAI,CAAT,IAAcD,MAAM,KAAK,KAA7B,EAAoC;AACvCpE,YAAAA,KAAK,CAACa,KAAN;;AACA,gBAAI,CAACb,KAAK,CAACC,MAAX,EAAmB;AACf,kBAAI,CAACH,GAAG,IAAI,OAAP,IAAkBA,GAAG,IAAI,OAAzB,IAAoCA,GAAG,IAAI,KAA5C,KAAsD5B,KAAK,CAACmC,KAAN,IAAe,IAAzE,EAA+E;AAC3E;AACH;;AACD,kBAAInC,KAAK,CAACmC,KAAN,IAAe,IAAf,IAAuBuD,GAAG,IAAI,CAAC,CAA/B,IAAoCS,KAAK,IAAI,CAAjD,EACI;AACJ,kBAAInG,KAAK,CAACmC,KAAN,IAAe,IAAnB,EACI;AACP;;AAED,gBAAIgE,KAAK,KAAK,CAAd,EAAiB;AACbrE,cAAAA,KAAK,CAACG,OAAN,CAAcjC,KAAK,CAACmC,KAApB;AACH;AACJ;AACJ;AACJ;;AAED,UAAI,CAACnC,KAAL,EACI,OAAO,IAAP;;AAEJ,UAAIqF,UAAJ,EAAgB;AACZQ,QAAAA,MAAM,CAACpE,IAAP,CAAY6D,MAAM,CAACQ,oBAAP,EAAZ;AACA,eAAOD,MAAP;AACH;;AAED,UAAIrC,GAAG,GAAG8B,MAAM,CAACc,kBAAP,EAAV;;AACA,UAAIV,GAAG,KAAK,CAAC,CAAb,EAAgB;AACZ,YAAI1F,KAAK,CAACwC,IAAN,KAAe,mBAAnB,EAAwC;AACpC,cAAIiE,SAAS,GAAG,CAAhB;AACH,SAFD,MAEO;AACH,cAAIA,SAAS,GAAG/B,OAAO,CAACjB,OAAR,CAAgBD,GAAhB,EAAqBzB,MAArC;AACH;;AACD,eAAO,IAAIiB,KAAJ,CAAUQ,GAAV,EAAeiD,SAAf,EAA0Bb,QAAQ,GAAG,CAArC,EAAwCD,WAAxC,CAAP;AACH,OAPD,MAQI,OAAO,IAAI3C,KAAJ,CAAU4C,QAAV,EAAoBD,WAApB,EAAiCnC,GAAG,GAAG,CAAvC,EAA0CkB,OAAO,CAACjB,OAAR,CAAgBD,GAAG,GAAG,CAAtB,EAAyBzB,MAAnE,CAAP;AACP,KAnJD;AAqJH,GAtPD,EAsPGkC,IAtPH,CAsPQG,QAAQ,CAACF,SAtPjB;AAwPC,CAtQD;AAwQA1E,GAAG,CAACC,MAAJ,CAAW,eAAX,EAA2B,CAAC,SAAD,EAAW,SAAX,EAAqB,QAArB,EAA8B,aAA9B,EAA4C,eAA5C,EAA4D,+BAA5D,EAA4F,iCAA5F,EAA8H,WAA9H,EAA0I,2BAA1I,EAAsK,uBAAtK,CAA3B,EAA2N,UAASC,OAAT,EAAkBC,OAAlB,EAA2BC,MAA3B,EAAmC;AAC9P;;AAEA,MAAIC,GAAG,GAAGH,OAAO,CAAC,YAAD,CAAjB;;AACA,MAAIgH,QAAQ,GAAGhH,OAAO,CAAC,QAAD,CAAP,CAAkBiH,IAAjC;;AACA,MAAI9F,kBAAkB,GAAGnB,OAAO,CAAC,wBAAD,CAAP,CAAkCmB,kBAA3D;;AACA,MAAIoC,oBAAoB,GAAGvD,OAAO,CAAC,0BAAD,CAAP,CAAoCuD,oBAA/D;;AACA,MAAID,KAAK,GAAGtD,OAAO,CAAC,UAAD,CAAP,CAAoBsD,KAAhC;;AACA,MAAI4D,eAAe,GAAGlH,OAAO,CAAC,oBAAD,CAAP,CAA8BkH,eAApD;;AACA,MAAIxC,QAAQ,GAAG1E,OAAO,CAAC,gBAAD,CAAP,CAA0B0E,QAAzC;;AAEA,MAAIuC,IAAI,GAAG,YAAW;AAClB,SAAKE,cAAL,GAAsBhG,kBAAtB;AACA,SAAKiG,QAAL,GAAgB,IAAI7D,oBAAJ,EAAhB;AACA,SAAK8D,UAAL,GAAkB,IAAIH,eAAJ,EAAlB;AACA,SAAKI,YAAL,GAAoB,IAAI5C,QAAJ,EAApB;AACA,SAAKE,cAAL,GAAsB,KAAK0C,YAAL,CAAkB1C,cAAxC;AACH,GAND;;AAOAzE,EAAAA,GAAG,CAACkD,QAAJ,CAAa4D,IAAb,EAAmBD,QAAnB;AAEA,GAAC,YAAW;AAGR,SAAKO,gBAAL,GAAwB,GAAxB;;AAEA,SAAKC,iBAAL,GAAyB,UAASrF,KAAT,EAAgBsB,IAAhB,EAAsBgE,GAAtB,EAA2B;AAChD,UAAIrD,MAAM,GAAG,KAAKC,UAAL,CAAgBZ,IAAhB,CAAb;AAEA,UAAIiE,aAAa,GAAG,KAAKC,YAAL,GAAoBC,aAApB,CAAkCnE,IAAlC,EAAwCtB,KAAxC,CAApB;AACA,UAAIQ,MAAM,GAAG+E,aAAa,CAAC/E,MAA3B;;AAEA,UAAIA,MAAM,CAACN,MAAP,IAAiBM,MAAM,CAACA,MAAM,CAACN,MAAP,GAAgB,CAAjB,CAAN,CAA0BS,IAA1B,IAAkC,SAAvD,EAAkE;AAC9D,eAAOsB,MAAP;AACH;;AAED,UAAIjC,KAAK,IAAI,OAAb,EAAsB;AAClB,YAAI6B,KAAK,GAAGP,IAAI,CAACO,KAAL,CAAW,iBAAX,CAAZ;AACA,YAAI6D,qBAAqB,GAAGpE,IAAI,CAACO,KAAL,CAAW,6BAAX,CAA5B;AACA,YAAI8D,eAAe,GAAGrE,IAAI,CAACO,KAAL,CAAW,yBAAX,CAAtB;AACA,YAAI+D,mBAAmB,GAAGtE,IAAI,CAACO,KAAL,CAAW,kEAAX,CAA1B;;AACA,YAAIA,KAAK,IAAI6D,qBAAT,IAAkCC,eAAlC,IAAqDC,mBAAzD,EAA8E;AAC1E3D,UAAAA,MAAM,IAAIqD,GAAV;AACH;AACJ;;AAED,aAAOrD,MAAP;AACH,KArBD;;AAuBA,SAAKZ,YAAL,GAAoB,UAASrB,KAAT,EAAgBsB,IAAhB,EAAsBC,KAAtB,EAA6B;AAC7C,aAAO,gCAAgCC,IAAhC,CAAqCF,IAAI,GAAGC,KAA5C,KAAsD,KAAK0D,QAAL,CAAc5D,YAAd,CAA2BC,IAA3B,EAAiCC,KAAjC,CAA7D;AACH,KAFD;;AAIA,SAAKE,WAAL,GAAmB,UAASzB,KAAT,EAAgB6C,OAAhB,EAAyBlB,GAAzB,EAA8B;AAC7C,UAAIL,IAAI,GAAGuB,OAAO,CAACjB,OAAR,CAAgBD,GAAhB,CAAX;AACA,UAAI,IAAIH,IAAJ,CAASF,IAAT,CAAJ,EACI,OAAO,KAAK2D,QAAL,CAAcxD,WAAd,CAA0BoB,OAA1B,EAAmClB,GAAnC,CAAP;AACJ,UAAIM,MAAM,GAAG,KAAKC,UAAL,CAAgBZ,IAAhB,CAAb;AACA,UAAIuE,QAAQ,GAAGhD,OAAO,CAACjB,OAAR,CAAgBD,GAAG,GAAG,CAAtB,CAAf;AACA,UAAImE,UAAU,GAAG,KAAK5D,UAAL,CAAgB2D,QAAhB,CAAjB;AACA,UAAIP,GAAG,GAAGzC,OAAO,CAACkD,YAAR,EAAV;;AACA,UAAID,UAAU,CAAC5F,MAAX,IAAqB+B,MAAM,CAAC/B,MAAhC,EAAwC;AACpC,YAAI+B,MAAM,CAAC+D,KAAP,CAAa,CAACV,GAAG,CAACpF,MAAlB,KAA6BoF,GAAjC,EACIzC,OAAO,CAACoD,MAAR,CAAe,IAAI9E,KAAJ,CAAUQ,GAAV,EAAeM,MAAM,CAAC/B,MAAP,GAAgBoF,GAAG,CAACpF,MAAnC,EAA2CyB,GAA3C,EAAgDM,MAAM,CAAC/B,MAAvD,CAAf;AACP;AACJ,KAZD;;AAcA,SAAKgG,WAAL,GAAmB,UAASrD,OAAT,EAAkBlB,GAAlB,EAAuBG,MAAvB,EAA+B;AAC9C,UAAIH,GAAG,IAAIwE,SAAX,EAAsB;AAClB,YAAIC,GAAG,GAAGvD,OAAO,CAACwD,SAAR,CAAkBC,IAA5B;AACAxE,QAAAA,MAAM,GAAGsE,GAAG,CAACtE,MAAb;AACAH,QAAAA,GAAG,GAAGyE,GAAG,CAACzE,GAAV;AACH;;AAED,UAAI4E,UAAU,GAAG1D,OAAO,CAACI,UAAR,CAAmBtB,GAAnB,EAAwBG,MAAxB,CAAjB;AACA,UAAIyE,UAAU,IAAIA,UAAU,CAACjG,KAAX,IAAoB,KAAKmC,cAA3C,EACI,OAAO,KAAK0C,YAAL,CAAkB9B,SAAlB,CAA4BR,OAA5B,EAAqClB,GAArC,EAA0CG,MAA1C,EAAkD,IAAlD,CAAP;AACP,KAVD;;AAYA,SAAK0E,GAAL,GAAW,eAAX;AACA,SAAKC,aAAL,GAAqB,mBAArB;AACH,GA5DD,EA4DGrE,IA5DH,CA4DQ0C,IAAI,CAACzC,SA5Db;AA8DAvE,EAAAA,OAAO,CAACgH,IAAR,GAAeA,IAAf;AACC,CAnFD;;AAmFmB,CAAC,YAAW;AACXnH,EAAAA,GAAG,CAACE,OAAJ,CAAY,CAAC,eAAD,CAAZ,EAA+B,UAAS6I,CAAT,EAAY;AACvC,QAAI,OAAO3I,MAAP,IAAiB,QAAjB,IAA6B,OAAOD,OAAP,IAAkB,QAA/C,IAA2DC,MAA/D,EAAuE;AACnEA,MAAAA,MAAM,CAACD,OAAP,GAAiB4I,CAAjB;AACH;AACJ,GAJD;AAKH,CANE","sourcesContent":["ace.define(\"ace/mode/ruby_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar constantOtherSymbol = exports.constantOtherSymbol = {\n    token : \"constant.other.symbol.ruby\", // symbol\n    regex : \"[:](?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?\"\n};\n\nexports.qString = {\n    token : \"string\", // single line\n    regex : \"['](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[']\"\n};\n\nexports.qqString = {\n    token : \"string\", // single line\n    regex : '[\"](?:(?:\\\\\\\\.)|(?:[^\"\\\\\\\\]))*?[\"]'\n};\n\nexports.tString = {\n    token : \"string\", // backtick string\n    regex : \"[`](?:(?:\\\\\\\\.)|(?:[^'\\\\\\\\]))*?[`]\"\n};\n\nvar constantNumericHex = exports.constantNumericHex = {\n    token : \"constant.numeric\", // hex\n    regex : \"0[xX][0-9a-fA-F](?:[0-9a-fA-F]|_(?=[0-9a-fA-F]))*\\\\b\"\n};\n\nvar constantNumericBinary = exports.constantNumericBinary = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[bB][01](?:[01]|_(?=[01]))*)\\b/\n};\n\nvar constantNumericDecimal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[dD](?:[1-9](?:[\\d]|_(?=[\\d]))*|0))\\b/\n};\n\nvar constantNumericOctal = exports.constantNumericDecimal = {\n    token: \"constant.numeric\",\n    regex: /\\b(0[oO]?(?:[1-7](?:[0-7]|_(?=[0-7]))*|0))\\b/\n};\n\nvar constantNumericRational = exports.constantNumericRational = {\n    token: \"constant.numeric\", //rational + complex\n    regex: /\\b([\\d]+(?:[./][\\d]+)?ri?)\\b/\n};\n\nvar constantNumericComplex = exports.constantNumericComplex = {\n    token: \"constant.numeric\", //simple complex numbers\n    regex: /\\b([\\d]i)\\b/\n};\n\nvar constantNumericFloat = exports.constantNumericFloat = {\n    token : \"constant.numeric\", // float + complex\n    regex : \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?i?\\\\b\"\n};\n\nvar instanceVariable = exports.instanceVariable = {\n    token : \"variable.instance\", // instance variable\n    regex : \"@{1,2}[a-zA-Z_\\\\d]+\"\n};\n\nvar RubyHighlightRules = function() {\n\n    var builtinFunctions = (\n        \"abort|Array|assert|assert_equal|assert_not_equal|assert_same|assert_not_same|\" +\n        \"assert_nil|assert_not_nil|assert_match|assert_no_match|assert_in_delta|assert_throws|\" +\n        \"assert_raise|assert_nothing_raised|assert_instance_of|assert_kind_of|assert_respond_to|\" +\n        \"assert_operator|assert_send|assert_difference|assert_no_difference|assert_recognizes|\" +\n        \"assert_generates|assert_response|assert_redirected_to|assert_template|assert_select|\" +\n        \"assert_select_email|assert_select_rjs|assert_select_encoded|css_select|at_exit|\" +\n        \"attr|attr_writer|attr_reader|attr_accessor|attr_accessible|autoload|binding|block_given?|callcc|\" +\n        \"caller|catch|chomp|chomp!|chop|chop!|defined?|delete_via_redirect|eval|exec|exit|\" +\n        \"exit!|fail|Float|flunk|follow_redirect!|fork|form_for|form_tag|format|gets|global_variables|gsub|\" +\n        \"gsub!|get_via_redirect|host!|https?|https!|include|Integer|lambda|link_to|\" +\n        \"link_to_unless_current|link_to_function|link_to_remote|load|local_variables|loop|open|open_session|\" +\n        \"p|print|printf|proc|putc|puts|post_via_redirect|put_via_redirect|raise|rand|\" +\n        \"raw|readline|readlines|redirect?|request_via_redirect|require|scan|select|\" +\n        \"set_trace_func|sleep|split|sprintf|srand|String|stylesheet_link_tag|syscall|system|sub|sub!|test|\" +\n        \"throw|trace_var|trap|untrace_var|atan2|cos|exp|frexp|ldexp|log|log10|sin|sqrt|tan|\" +\n        \"render|javascript_include_tag|csrf_meta_tag|label_tag|text_field_tag|submit_tag|check_box_tag|\" +\n        \"content_tag|radio_button_tag|text_area_tag|password_field_tag|hidden_field_tag|\" +\n        \"fields_for|select_tag|options_for_select|options_from_collection_for_select|collection_select|\" +\n        \"time_zone_select|select_date|select_time|select_datetime|date_select|time_select|datetime_select|\" +\n        \"select_year|select_month|select_day|select_hour|select_minute|select_second|file_field_tag|\" +\n        \"file_field|respond_to|skip_before_filter|around_filter|after_filter|verify|\" +\n        \"protect_from_forgery|rescue_from|helper_method|redirect_to|before_filter|\" +\n        \"send_data|send_file|validates_presence_of|validates_uniqueness_of|validates_length_of|\" +\n        \"validates_format_of|validates_acceptance_of|validates_associated|validates_exclusion_of|\" +\n        \"validates_inclusion_of|validates_numericality_of|validates_with|validates_each|\" +\n        \"authenticate_or_request_with_http_basic|authenticate_or_request_with_http_digest|\" +\n        \"filter_parameter_logging|match|get|post|resources|redirect|scope|assert_routing|\" +\n        \"translate|localize|extract_locale_from_tld|caches_page|expire_page|caches_action|expire_action|\" +\n        \"cache|expire_fragment|expire_cache_for|observe|cache_sweeper|\" +\n        \"has_many|has_one|belongs_to|has_and_belongs_to_many|p|warn|refine|using|module_function|extend|alias_method|\" +\n        \"private_class_method|remove_method|undef_method\"\n    );\n\n    var keywords = (\n        \"alias|and|BEGIN|begin|break|case|class|def|defined|do|else|elsif|END|end|ensure|\" +\n        \"__FILE__|finally|for|gem|if|in|__LINE__|module|next|not|or|private|protected|public|\" +\n        \"redo|rescue|retry|return|super|then|undef|unless|until|when|while|yield|__ENCODING__|prepend\"\n    );\n\n    var buildinConstants = (\n        \"true|TRUE|false|FALSE|nil|NIL|ARGF|ARGV|DATA|ENV|RUBY_PLATFORM|RUBY_RELEASE_DATE|\" +\n        \"RUBY_VERSION|STDERR|STDIN|STDOUT|TOPLEVEL_BINDING|RUBY_PATCHLEVEL|RUBY_REVISION|RUBY_COPYRIGHT|RUBY_ENGINE|RUBY_ENGINE_VERSION|RUBY_DESCRIPTION\"\n    );\n\n    var builtinVariables = (\n        \"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"$!|root_url|flash|session|cookies|params|request|response|logger|self\"\n    );\n\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions,\n        \"invalid.deprecated\": \"debugger\" // TODO is this a remnant from js mode?\n    }, \"identifier\");\n\n    var escapedChars = \"\\\\\\\\(?:n(?:[1-7][0-7]{0,2}|0)|[nsrtvfbae'\\\"\\\\\\\\]|c(?:\\\\\\\\M-)?.|M-(?:\\\\\\\\C-|\\\\\\\\c)?.|C-(?:\\\\\\\\M-)?.|[0-7]{3}|x[\\\\da-fA-F]{2}|u[\\\\da-fA-F]{4}|u{[\\\\da-fA-F]{1,6}(?:\\\\s[\\\\da-fA-F]{1,6})*})\";\n\n    var closeParen = {\n        \"(\": \")\",\n        \"[\": \"]\",\n        \"{\": \"}\",\n        \"<\": \">\",\n        \"^\": \"^\",\n        \"|\": \"|\",\n        \"%\": \"%\"\n    };\n\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"comment.multiline\", // multi line comment\n                regex: \"^=begin(?=$|\\\\s.*$)\",\n                next: \"comment\"\n            }, {\n                token: \"string.regexp\",\n                regex: /[/](?=.*\\/)/,\n                next: \"regex\"\n            },\n\n            [{\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(\")/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /\"/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",\n                regex: /`/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: escapedChars\n                }, {\n                    token: \"paren.start\",\n                    regex: /#{/,\n                    push: \"start\"\n                }, {\n                    token: \"string.end\",\n                    regex: /`/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: [\"constant.other.symbol.ruby\", \"string.start\"],\n                regex: /(:)?(')/,\n                push: [{\n                    token: \"constant.language.escape\",\n                    regex: /\\\\['\\\\]/\n                }, {\n                    token: \"string.end\",\n                    regex: /'/,\n                    next: \"pop\"\n                }, {\n                    defaultToken: \"string\"\n                }]\n            }, {\n                token: \"string.start\",//doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[qwx]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.start\", //doesn't see any differences between strings and array of strings in highlighting\n                regex: /%[QWX]?([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"qStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[si]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithoutInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"constant.other.symbol.ruby\", //doesn't see any differences between symbols and array of symbols in highlighting\n                regex: /%[SI]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"sStateWithInterpolation\";\n                    return this.token;\n                }\n            }, {\n                token: \"string.regexp\",\n                regex: /%[r]([(\\[<{^|%])/, onMatch: function (val, state, stack) {\n                    if (stack.length)\n                        stack = [];\n                    var paren = val[val.length - 1];\n                    stack.unshift(paren, state);\n                    this.next = \"rState\";\n                    return this.token;\n                }\n            }],\n\n            {\n                token: \"punctuation\", // namespaces aren't symbols\n                regex: \"::\"\n            },\n            instanceVariable,\n            {\n                token: \"variable.global\", // global variable\n                regex: \"[$][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\", // class name\n                regex: \"[A-Z][a-zA-Z_\\\\d]*\"\n            }, {\n                token: [\"punctuation.operator\", \"support.function\"],\n                regex: /(\\.)([a-zA-Z_\\d]+)(?=\\()/\n            }, {\n                token: [\"punctuation.operator\", \"identifier\"],\n                regex: /(\\.)([a-zA-Z_][a-zA-Z_\\d]*)/\n            }, {\n                token: \"string.character\",\n                regex: \"\\\\B\\\\?(?:\" + escapedChars + \"|\\\\S)\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /\\?(?=.+:)/\n            },\n\n            constantNumericRational,\n            constantNumericComplex,\n            constantOtherSymbol,\n            constantNumericHex,\n            constantNumericFloat,\n            constantNumericBinary,\n            constantNumericDecimal,\n            constantNumericOctal,\n            {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = (value[2] == '-' || value[2] == '~') ? \"indentedHeredoc\" : \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        {type: \"constant\", value: tokens[1]},\n                        {type: \"string\", value: tokens[2]},\n                        {type: \"support.class\", value: tokens[3]},\n                        {type: \"string\", value: tokens[4]}\n                    ];\n                },\n                regex: \"(<<[-~]?)(['\\\"`]?)([\\\\w]+)(['\\\"`]?)\",\n                rules: {\n                    heredoc: [{\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }],\n                    indentedHeredoc: [{\n                        token: \"string\",\n                        regex: \"^ +\"\n                    }, {\n                        onMatch: function(value, currentState, stack) {\n                            if (value === stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack[0] || \"start\";\n                                return \"support.class\";\n                            }\n                            this.next = \"\";\n                            return \"string\";\n                        },\n                        regex: \".*$\",\n                        next: \"start\"\n                    }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function(currentState, stack) {\n                    if (stack[0] === \"heredoc\" || stack[0] === \"indentedHeredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            },  {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|/|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\||\\\\b(?:in|instanceof|new|delete|typeof|void)\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\",\n                onMatch: function(value, currentState, stack) {\n                    this.next = '';\n                    if (value == \"}\" && stack.length > 1 && stack[1] != \"start\") {\n                        stack.shift();\n                        this.next = stack.shift();\n                    }\n                    return this.token;\n                }\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }\n        ],\n        \"comment\": [\n            {\n                token: \"comment.multiline\", // closing comment\n                regex: \"^=end(?=$|\\\\s.*$)\",\n                next: \"start\"\n            }, {\n                token: \"comment\", // comment spanning whole line\n                regex: \".+\"\n            }\n        ],\n        \"qStateWithInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"qStateWithoutInterpolation\": [{\n            token: \"string.start\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"string\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\['\\\\]/\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"string.end\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"string\";\n            }\n        }, {\n            defaultToken: \"string\"\n        }],\n        \"sStateWithoutInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"sStateWithInterpolation\": [{\n            token: \"constant.other.symbol.ruby\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            token: \"constant.language.escape\",\n            regex: escapedChars\n        }, {\n            token: \"constant.language.escape\",\n            regex: /\\\\./\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"constant.other.symbol.ruby\",\n            regex: /[)\\]>}^|%]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.other.symbol.ruby\";\n            }\n        }, {\n            defaultToken: \"constant.other.symbol.ruby\"\n        }],\n        \"rState\": [{\n            token: \"string.regexp\",// excluded nested |^% due to difficulty in realization\n            regex: /[(\\[<{]/, onMatch: function (val, state, stack) {\n                if (stack.length && val === stack[0]) {\n                    stack.unshift(val, state);\n                    return this.token;\n                }\n                return \"constant.language.escape\";\n            }\n        }, {\n            token: \"paren.start\",\n            regex: /#{/,\n            push: \"start\"\n        }, {\n            token: \"string.regexp\",\n            regex: /\\//\n        }, {\n            token: \"string.regexp\",\n            regex: /[)\\]>}^|%][imxouesn]*/, onMatch: function (val, state, stack) {\n                if (stack.length && val[0] === closeParen[stack[0]]) {\n                    stack.shift();\n                    this.next = stack.shift();\n                    return this.token;\n                }\n                this.next = '';\n                return \"constant.language.escape\";\n            }\n        },\n            {include: \"regex\"},\n            {\n                defaultToken: \"string.regexp\"\n            }],\n        \"regex\": [\n            {// character classes\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\[AGbBzZ]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\\\g<[a-zA-Z0-9]*>/\n            }, {\n                token: [\"constant.language.escape\", \"regexp.keyword\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)(Alnum|Alpha|Blank|Cntrl|Digit|Graph|Lower|Print|Punct|Space|Upper|XDigit|Word|ASCII|Any|Assigned|Arabic|Armenian|Balinese|Bengali|Bopomofo|Braille|Buginese|Buhid|Canadian_Aboriginal|Carian|Cham|Cherokee|Common|Coptic|Cuneiform|Cypriot|Cyrillic|Deseret|Devanagari|Ethiopic|Georgian|Glagolitic|Gothic|Greek|Gujarati|Gurmukhi|Han|Hangul|Hanunoo|Hebrew|Hiragana|Inherited|Kannada|Katakana|Kayah_Li|Kharoshthi|Khmer|Lao|Latin|Lepcha|Limbu|Linear_B|Lycian|Lydian|Malayalam|Mongolian|Myanmar|New_Tai_Lue|Nko|Ogham|Ol_Chiki|Old_Italic|Old_Persian|Oriya|Osmanya|Phags_Pa|Phoenician|Rejang|Runic|Saurashtra|Shavian|Sinhala|Sundanese|Syloti_Nagri|Syriac|Tagalog|Tagbanwa|Tai_Le|Tamil|Telugu|Thaana|Thai|Tibetan|Tifinagh|Ugaritic|Vai|Yi|Ll|Lm|Lt|Lu|Lo|Mn|Mc|Me|Nd|Nl|Pc|Pd|Ps|Pe|Pi|Pf|Po|No|Sm|Sc|Sk|So|Zs|Zl|Zp|Cc|Cf|Cn|Co|Cs|N|L|M|P|S|Z|C)(})/\n            }, {\n                token: [\"constant.language.escape\", \"invalid\", \"constant.language.escape\"],\n                regex: /(\\\\p{\\^?)([^/]*)(})/\n            }, {// escapes\n                token: \"regexp.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {// flag\n                token: \"string.regexp\",\n                regex: /[/][imxouesn]*/,\n                next: \"start\"\n            }, {// invalid operators\n                token: \"invalid\",\n                regex: /\\{\\d+\\b,?\\d*\\}[+*]|[+*$^?][+*]|[$^][?]|\\?{3,}/\n            }, {// operators\n                token: \"constant.language.escape\",\n                regex: /\\(\\?(?:[:=!>]|<'?[a-zA-Z]*'?>|<[=!])|\\)|\\{\\d+\\b,?\\d*\\}|[+*]\\?|[()$^+*?.]/\n            }, {\n                token: \"constant.language.delimiter\",\n                regex: /\\|/\n            }, {\n                token: \"regexp.keyword\",\n                regex: /\\[\\[:(?:alnum|alpha|blank|cntrl|digit|graph|lower|print|punct|space|upper|xdigit|word|ascii):\\]\\]/\n            }, {\n                token: \"constant.language.escape\",\n                regex: /\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                defaultToken: \"string.regexp\"\n            }\n        ],\n        \"regex_character_class\": [\n            {\n                token: \"regexp.keyword\",\n                regex: /\\\\[wWdDhHsS]/\n            }, {\n                token: \"regexp.charclass.keyword.operator\",\n                regex: \"\\\\\\\\(?:u[\\\\da-fA-F]{4}|x[\\\\da-fA-F]{2}|.)\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: /&?&?\\[\\^?/,\n                push: \"regex_character_class\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"]\",\n                next: \"pop\"\n            }, {\n                token: \"constant.language.escape\",\n                regex: \"-\"\n            }, {\n                defaultToken: \"string.regexp.characterclass\"\n            }\n        ]\n    };\n\n    this.normalizeRules();\n};\n\noop.inherits(RubyHighlightRules, TextHighlightRules);\n\nexports.RubyHighlightRules = RubyHighlightRules;\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n\"use strict\";\n\nvar Range = require(\"../range\").Range;\n\nvar MatchingBraceOutdent = function() {};\n\n(function() {\n\n    this.checkOutdent = function(line, input) {\n        if (! /^\\s+$/.test(line))\n            return false;\n\n        return /^\\s*\\}/.test(input);\n    };\n\n    this.autoOutdent = function(doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n\n        if (!match) return 0;\n\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({row: row, column: column});\n\n        if (!openBracePos || openBracePos.row == row) return 0;\n\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column-1), indent);\n    };\n\n    this.$getIndent = function(line) {\n        return line.match(/^\\s*/)[0];\n    };\n\n}).call(MatchingBraceOutdent.prototype);\n\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n});\n\nace.define(\"ace/mode/folding/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function (require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\n\n\nvar FoldMode = exports.FoldMode = function () {\n};\n\noop.inherits(FoldMode, BaseFoldMode);\n\n(function () {\n    this.indentKeywords = {\n        \"class\": 1,\n        \"def\": 1,\n        \"module\": 1,\n        \"do\": 1,\n        \"unless\": 1,\n        \"if\": 1,\n        \"while\": 1,\n        \"for\": 1,\n        \"until\": 1,\n        \"begin\": 1,\n        \"else\": 0,\n        \"elsif\": 0,\n        \"rescue\": 0,\n        \"ensure\": 0,\n        \"when\": 0,\n        \"end\": -1,\n        \"case\": 1,\n        \"=begin\": 1,\n        \"=end\": -1\n    };\n\n    this.foldingStartMarker = /(?:\\s|^)(def|do|while|class|unless|module|if|for|until|begin|else|elsif|case|rescue|ensure|when)\\b|({\\s*$)|(=begin)/;\n    this.foldingStopMarker = /(=end(?=$|\\s.*$))|(^\\s*})|\\b(end)\\b/;\n\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1]) {\n                if (match[1] == \"if\" || match[1] == \"else\" || match[1] == \"while\" || match[1] == \"until\" || match[1] == \"unless\") {\n                    if (match[1] == \"else\" && /^\\s*else\\s*$/.test(line) === false) {\n                        return;\n                    }\n                    if (/^\\s*(?:if|else|while|until|unless)\\s*/.test(line) === false) {\n                        return;\n                    }\n                }\n\n                if (match[1] == \"when\") {\n                    if (/\\sthen\\s/.test(line) === true) {\n                        return;\n                    }\n                }\n                if (session.getTokenAt(row, match.index + 2).type === \"keyword\")\n                    return \"start\";\n            } else if (match[3]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return \"start\";\n            } else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n\n        var match = line.match(this.foldingStopMarker);\n        if (match[3] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        } else if (match[1]) {\n            if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                return \"end\";\n        } else\n            return \"end\";\n    };\n\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1] || match[3])\n                return this.rubyBlock(session, row, match.index + 2);\n\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[3] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            if (match[1] === \"=end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"comment.multiline\")\n                    return this.rubyBlock(session, row, match.index + 1);\n            }\n\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n\n    this.rubyBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n\n        var token = stream.getCurrentToken();\n        if (!token || (token.type != \"keyword\" && token.type != \"comment.multiline\"))\n            return;\n\n        var val = token.value;\n        var line = session.getLine(row);\n        switch (token.value) {\n            case \"if\":\n            case \"unless\":\n            case \"while\":\n            case \"until\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = this.indentKeywords[val];\n                break;\n            case \"when\":\n                if (/\\sthen\\s/.test(line)) {\n                    return;\n                }\n            case \"elsif\":\n            case \"rescue\":\n            case \"ensure\":\n                var dir = 1;\n                break;\n            case \"else\":\n                var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                if (!checkToken.test(line)) {\n                    return;\n                }\n                var dir = 1;\n                break;\n            default:\n                var dir = this.indentKeywords[val];\n                break;\n        }\n\n        var stack = [val];\n        if (!dir)\n            return;\n\n        var startColumn = dir === -1 ? session.getLine(row - 1).length : session.getLine(row).length;\n        var startRow = row;\n        var ranges = [];\n        ranges.push(stream.getCurrentTokenRange());\n\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        if (token.type == \"comment.multiline\") {\n            while (token = stream.step()) {\n                if (token.type !== \"comment.multiline\")\n                    continue;\n                if (dir == 1) {\n                    startColumn = 6;\n                    if (token.value == \"=end\") {\n                        break;\n                    }\n                } else {\n                    if (token.value == \"=begin\") {\n                        break;\n                    }\n                }\n            }\n        } else {\n            while (token = stream.step()) {\n                var ignore = false;\n                if (token.type !== \"keyword\")\n                    continue;\n                var level = dir * this.indentKeywords[token.value];\n                line = session.getLine(stream.getCurrentTokenRow());\n                switch (token.value) {\n                    case \"do\":\n                        for (var i = stream.$tokenIndex - 1; i >= 0; i--) {\n                            var prevToken = stream.$rowTokens[i];\n                            if (prevToken && (prevToken.value == \"while\" || prevToken.value == \"until\" || prevToken.value == \"for\")) {\n                                level = 0;\n                                break;\n                            }\n                        }\n                        break;\n                    case \"else\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value + \"\\\\s*$\");\n                        if (!checkToken.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"if\":\n                    case \"unless\":\n                    case \"while\":\n                    case \"until\":\n                        var checkToken = new RegExp(\"^\\\\s*\" + token.value);\n                        if (!checkToken.test(line)) {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                    case \"when\":\n                        if (/\\sthen\\s/.test(line) || val == \"case\") {\n                            level = 0;\n                            ignore = true;\n                        }\n                        break;\n                }\n\n                if (level > 0) {\n                    stack.unshift(token.value);\n                } else if (level <= 0 && ignore === false) {\n                    stack.shift();\n                    if (!stack.length) {\n                        if ((val == \"while\" || val == \"until\" || val == \"for\") && token.value != \"do\") {\n                            break;\n                        }\n                        if (token.value == \"do\" && dir == -1 && level != 0)\n                            break;\n                        if (token.value != \"do\")\n                            break;\n                    }\n\n                    if (level === 0) {\n                        stack.unshift(token.value);\n                    }\n                }\n            }\n        }\n\n        if (!token)\n            return null;\n\n        if (tokenRange) {\n            ranges.push(stream.getCurrentTokenRange());\n            return ranges;\n        }\n\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1) {\n            if (token.type === \"comment.multiline\") {\n                var endColumn = 6;\n            } else {\n                var endColumn = session.getLine(row).length;\n            }\n            return new Range(row, endColumn, startRow - 1, startColumn);\n        } else\n            return new Range(startRow, startColumn, row - 1, session.getLine(row - 1).length);\n    };\n\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/ruby\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/ruby_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/behaviour/cstyle\",\"ace/mode/folding/ruby\"], function(require, exports, module) {\n\"use strict\";\n\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar RubyHighlightRules = require(\"./ruby_highlight_rules\").RubyHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar CstyleBehaviour = require(\"./behaviour/cstyle\").CstyleBehaviour;\nvar FoldMode = require(\"./folding/ruby\").FoldMode;\n\nvar Mode = function() {\n    this.HighlightRules = RubyHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = new CstyleBehaviour();\n    this.foldingRules = new FoldMode();\n    this.indentKeywords = this.foldingRules.indentKeywords;\n};\noop.inherits(Mode, TextMode);\n\n(function() {\n\n\n    this.lineCommentStart = \"#\";\n\n    this.getNextLineIndent = function(state, line, tab) {\n        var indent = this.$getIndent(line);\n\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when|elsif|unless|while|for|begin|rescue|ensure)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n\n        return indent;\n    };\n\n    this.checkOutdent = function(state, line, input) {\n        return /^\\s+(end|else|rescue|ensure)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n\n    this.autoOutdent = function(state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n\n    this.getMatching = function(session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in this.indentKeywords)\n            return this.foldingRules.rubyBlock(session, row, column, true);\n    };\n\n    this.$id = \"ace/mode/ruby\";\n    this.snippetFileId = \"ace/snippets/ruby\";\n}).call(Mode.prototype);\n\nexports.Mode = Mode;\n});                (function() {\n                    ace.require([\"ace/mode/ruby\"], function(m) {\n                        if (typeof module == \"object\" && typeof exports == \"object\" && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            "]},"metadata":{},"sourceType":"script"}