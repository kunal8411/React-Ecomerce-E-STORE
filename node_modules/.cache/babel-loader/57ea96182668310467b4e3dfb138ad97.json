{"ast":null,"code":"/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = function split(undef) {\n  var nativeSplit = String.prototype.split,\n      compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n      // NPCG: nonparticipating capturing group\n  self;\n\n  self = function (str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n\n    var output = [],\n        flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + ( // Proposed for ES6\n    separator.sticky ? \"y\" : \"\"),\n        // Firefox 3+\n    lastLastIndex = 0,\n        // Make `global` and avoid `lastIndex` issues by working with a copy\n    separator = new RegExp(separator.source, flags + \"g\"),\n        separator2,\n        match,\n        lastIndex,\n        lastLength;\n    str += \"\"; // Type-convert\n\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n\n\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index)); // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function () {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n\n        if (output.length >= limit) {\n          break;\n        }\n      }\n\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n}();","map":{"version":3,"sources":["/home/kunal/Kunal/THEMES/theme/node_modules/browser-split/index.js"],"names":["module","exports","split","undef","nativeSplit","String","prototype","compliantExecNpcg","exec","self","str","separator","limit","Object","toString","call","output","flags","ignoreCase","multiline","extended","sticky","lastLastIndex","RegExp","source","separator2","match","lastIndex","lastLength","index","length","push","slice","replace","i","arguments","Array","apply","test"],"mappings":"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","sourcesContent":["/*!\n * Cross-Browser Split 1.1.1\n * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>\n * Available under the MIT License\n * ECMAScript compliant, uniform cross-browser split method\n */\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * split('a b c d', ' ');\n * // -> ['a', 'b', 'c', 'd']\n *\n * // With limit\n * split('a b c d', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * split('..word1 word2..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', ' ', 'word', '2', '..']\n */\nmodule.exports = (function split(undef) {\n\n  var nativeSplit = String.prototype.split,\n    compliantExecNpcg = /()??/.exec(\"\")[1] === undef,\n    // NPCG: nonparticipating capturing group\n    self;\n\n  self = function(str, separator, limit) {\n    // If `separator` is not a regex, use `nativeSplit`\n    if (Object.prototype.toString.call(separator) !== \"[object RegExp]\") {\n      return nativeSplit.call(str, separator, limit);\n    }\n    var output = [],\n      flags = (separator.ignoreCase ? \"i\" : \"\") + (separator.multiline ? \"m\" : \"\") + (separator.extended ? \"x\" : \"\") + // Proposed for ES6\n      (separator.sticky ? \"y\" : \"\"),\n      // Firefox 3+\n      lastLastIndex = 0,\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      separator = new RegExp(separator.source, flags + \"g\"),\n      separator2, match, lastIndex, lastLength;\n    str += \"\"; // Type-convert\n    if (!compliantExecNpcg) {\n      // Doesn't need flags gy, but they don't hurt\n      separator2 = new RegExp(\"^\" + separator.source + \"$(?!\\\\s)\", flags);\n    }\n    /* Values for `limit`, per the spec:\n     * If undefined: 4294967295 // Math.pow(2, 32) - 1\n     * If 0, Infinity, or NaN: 0\n     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;\n     * If negative number: 4294967296 - Math.floor(Math.abs(limit))\n     * If other: Type-convert, then use the above rules\n     */\n    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1\n    limit >>> 0; // ToUint32(limit)\n    while (match = separator.exec(str)) {\n      // `separator.lastIndex` is not reliable cross-browser\n      lastIndex = match.index + match[0].length;\n      if (lastIndex > lastLastIndex) {\n        output.push(str.slice(lastLastIndex, match.index));\n        // Fix browsers whose `exec` methods don't consistently return `undefined` for\n        // nonparticipating capturing groups\n        if (!compliantExecNpcg && match.length > 1) {\n          match[0].replace(separator2, function() {\n            for (var i = 1; i < arguments.length - 2; i++) {\n              if (arguments[i] === undef) {\n                match[i] = undef;\n              }\n            }\n          });\n        }\n        if (match.length > 1 && match.index < str.length) {\n          Array.prototype.push.apply(output, match.slice(1));\n        }\n        lastLength = match[0].length;\n        lastLastIndex = lastIndex;\n        if (output.length >= limit) {\n          break;\n        }\n      }\n      if (separator.lastIndex === match.index) {\n        separator.lastIndex++; // Avoid an infinite loop\n      }\n    }\n    if (lastLastIndex === str.length) {\n      if (lastLength || !separator.test(\"\")) {\n        output.push(\"\");\n      }\n    } else {\n      output.push(str.slice(lastLastIndex));\n    }\n    return output.length > limit ? output.slice(0, limit) : output;\n  };\n\n  return self;\n})();\n"]},"metadata":{},"sourceType":"script"}